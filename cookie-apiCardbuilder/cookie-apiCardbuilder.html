<!--
████████╗██████╗  ██████╗ ██╗     ███████╗███╗   ██╗███████╗
╚══██╔══╝██╔══██╗██╔═══██╗██║     ██╔════╝████╗  ██║██╔════╝
   ██║   ██████╔╝██║   ██║██║     █████╗  ██╔██╗ ██║███████╗
   ██║   ██╔══██╗██║   ██║██║     ██╔══╝  ██║╚██╗██║╚════██║
   ██║   ██║  ██║╚██████╔╝███████╗███████╗██║ ╚████║███████║
   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═══╝╚══════╝
                                    
                        Designed by Trolens
-->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Trolens Cookie API Card Builder</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Inter:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            color: #ffffff;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Trolens Brand Header */
        .trolens-header {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(255, 107, 53, 0.3);
            border-bottom: 2px solid #ff6b35;
        }

        .trolens-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .trolens-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .trolens-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .avatar-fallback {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #ffffff;
        }

        .trolens-brand {
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .trolens-tagline {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: -4px;
        }

        .version-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            color: #ffffff;
        }

        .container {
            display: grid;
            grid-template-columns: 240px 1fr 280px;
            height: calc(100vh - 64px);
            gap: 1px;
            background: #3a3a3a;
        }

        /* Left Panel - Elements */
        .left-panel {
            background: #2a2a3a;
            padding: 12px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #ff6b35;
        }

        .element-group {
            margin-bottom: 16px;
        }

        .element-group h3 {
            font-size: 11px;
            color: #a0a0a0;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .element-btn {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: linear-gradient(135deg, #4a4a5a 0%, #3a3a4a 100%);
            border: 1px solid #5a5a6a;
            border-radius: 6px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .element-btn:hover {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            border-color: #ff6b35;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .element-btn:active {
            transform: translateY(0);
        }

        .element-icon {
            width: 16px;
            height: 16px;
            background: #ff6b35;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .quota {
            font-size: 10px;
            color: #888;
            margin-left: auto;
        }

        /* Center Panel - Canvas */
        .center-panel {
            background: #1a1a2a;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-header {
            padding: 12px 16px;
            background: #2a2a3a;
            border-bottom: 1px solid #3a3a4a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canvas-title {
            font-size: 14px;
            font-weight: 600;
        }

        .canvas-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .control-group label {
            font-size: 11px;
            color: #a0a0a0;
        }

        .control-group input, .control-group select {
            padding: 4px 8px;
            background: #3a3a4a;
            border: 1px solid #5a5a6a;
            border-radius: 4px;
            color: #ffffff;
            font-size: 11px;
            width: 60px;
        }

        .quick-actions {
            background: #2a2a3a;
            border-bottom: 1px solid #3a3a4a;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .quick-actions-title {
            font-size: 11px;
            color: #a0a0a0;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-right: 8px;
        }

        .quick-actions-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .quick-action-btn {
            padding: 4px 8px;
            background: linear-gradient(135deg, #4a4a5a 0%, #3a3a4a 100%);
            border: 1px solid #5a5a6a;
            border-radius: 4px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 10px;
            font-weight: 500;
        }

        .quick-action-btn:hover {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            border-color: #ff6b35;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.3);
        }

        .quick-action-btn:active {
            transform: translateY(0);
        }

        .quick-action-btn span {
            font-size: 12px;
        }

        .quick-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .quick-action-btn:disabled:hover {
            background: linear-gradient(135deg, #4a4a5a 0%, #3a3a4a 100%);
            border-color: #5a5a6a;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .canvas {
            background: #ffffff;
            border: 2px solid #ff6b35;
            border-radius: 0px;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            cursor: default;
        }

        .canvas.resize-cursor {
            cursor: se-resize;
        }

        .canvas-resize-handle {
            position: absolute;
            bottom: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            background: #ff6b35;
            border: 3px solid #ffffff;
            border-radius: 50%;
            cursor: se-resize;
            opacity: 1;
            transition: all 0.2s ease;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.6);
            pointer-events: auto;
        }

        .canvas:hover .canvas-resize-handle {
            opacity: 1;
        }

        .canvas-resize-handle:hover {
            opacity: 1 !important;
            transform: scale(1.2);
        }

        .canvas.transparent {
            background: transparent;
            background-image: 
                linear-gradient(45deg, rgba(200, 200, 200, 0.15) 25%, transparent 25%), 
                linear-gradient(-45deg, rgba(200, 200, 200, 0.15) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, rgba(200, 200, 200, 0.15) 75%), 
                linear-gradient(-45deg, transparent 75%, rgba(200, 200, 200, 0.15) 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
        }

        .canvas-element {
            position: absolute;
            cursor: move;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .canvas-element:hover {
            border-color: #ff6b35;
        }

        .canvas-element.selected {
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.3);
        }

        .canvas-element .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff6b35;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .canvas-element.selected .resize-handle {
            opacity: 1;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }

        /* Right Panel - Properties */
        .right-panel {
            background: #2a2a3a;
            padding: 12px;
            overflow-y: auto;
        }

        .property-group {
            margin-bottom: 12px;
        }

        .property-group h3 {
            font-size: 11px;
            color: #a0a0a0;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .property-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 6px;
        }

        .property-row.single {
            grid-template-columns: 1fr;
        }

        .property-row label {
            font-size: 10px;
            color: #ffffff;
            margin-bottom: 2px;
            display: block;
        }

        .property-row input, .property-row select, .property-row textarea {
            width: 100%;
            padding: 6px 8px;
            background: #3a3a4a;
            border: 1px solid #5a5a6a;
            border-radius: 4px;
            color: #ffffff;
            font-size: 11px;
        }

        .property-row input:focus, .property-row select:focus, .property-row textarea:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
        }

        .json-output {
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 6px;
            padding: 8px;
            margin-top: 12px;
        }

        .json-output h3 {
            font-size: 11px;
            color: #ff6b35;
            margin-bottom: 6px;
        }

        .json-textarea {
            width: 100%;
            height: 120px;
            background: #0a0a1a;
            border: 1px solid #3a3a4a;
            border-radius: 4px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            padding: 6px;
            resize: vertical;
        }

        .copy-btn {
            width: 100%;
            padding: 6px;
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            border: none;
            border-radius: 4px;
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            margin-top: 6px;
            transition: all 0.3s ease;
            font-size: 11px;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .no-selection {
            text-align: center;
            color: #666;
            font-style: italic;
            margin-top: 50px;
        }

        /* Layers Panel */
        .layers-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #3a3a4a;
            border-radius: 4px;
            background: #1a1a2a;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-bottom: 1px solid #2a2a3a;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .layer-item:hover {
            background: #3a3a4a;
        }

        .layer-item.card-layer {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            border-color: #ff6b35;
        }

        .layer-item.card-layer:hover {
            background: linear-gradient(135deg, #ff8c42 0%, #ff6b35 100%);
        }

        .layer-item.card-layer .layer-name {
            font-weight: 600;
            color: #ffffff;
        }

        .layer-item.card-layer .layer-details {
            color: rgba(255, 255, 255, 0.8);
        }

        .layer-item.selected {
            background: #ff6b35;
            color: #ffffff;
        }

        .layer-item:last-child {
            border-bottom: none;
        }

        .layer-icon {
            width: 16px;
            height: 16px;
            background: #ff6b35;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            margin-right: 6px;
            flex-shrink: 0;
        }

        .layer-info {
            flex: 1;
            min-width: 0;
        }

        .layer-name {
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-details {
            font-size: 9px;
            color: #a0a0a0;
            margin-top: 1px;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .layer-item:hover .layer-controls {
            opacity: 1;
        }

        .layer-btn {
            width: 16px;
            height: 16px;
            background: #4a4a5a;
            border: none;
            border-radius: 2px;
            color: #ffffff;
            cursor: pointer;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .layer-btn:hover {
            background: #ff6b35;
        }

        .layer-btn.delete:hover {
            background: #ff4757;
        }

        .no-layers {
            padding: 12px;
            text-align: center;
            color: #666;
            font-style: italic;
            font-size: 10px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal-content {
            background: #2a2a3a;
            border-radius: 12px;
            max-width: 800px;
            max-height: 80vh;
            width: 90%;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            color: #ffffff;
            font-size: 18px;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            color: #ffffff;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s ease;
        }

        .modal-close:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .guide-section {
            margin-bottom: 24px;
        }

        .guide-section h3 {
            color: #ff6b35;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .guide-section ol, .guide-section ul {
            color: #ffffff;
            font-size: 12px;
            line-height: 1.5;
            padding-left: 16px;
        }

        .guide-section li {
            margin-bottom: 4px;
        }

        .code-block {
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 6px;
            padding: 12px;
            margin: 8px 0;
        }

        .code-block pre {
            margin: 0;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
            overflow-x: auto;
        }

        .code-block code {
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .code-block strong {
            color: #ff6b35;
        }

        .guide-section a {
            color: #ff6b35;
            text-decoration: none;
        }

        .guide-section a:hover {
            text-decoration: underline;
        }

        /* Mobile-First Responsive Design */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 200px 1fr 240px;
            }
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
                height: 100vh;
            }
            
            .left-panel, .right-panel {
                max-height: 200px;
                overflow-y: auto;
            }
            
            .canvas-container {
                min-height: 300px;
            }
            
            .trolens-header {
                padding: 8px 16px;
            }
            
            .trolens-brand {
                font-size: 20px;
            }
            
            .trolens-avatar {
                width: 32px;
                height: 32px;
            }
            
            .avatar-fallback {
                font-size: 16px;
            }

            .modal-content {
                width: 95%;
                max-height: 90vh;
            }
        }

        /* Mobile Optimizations - Completely Redesigned */
        @media (max-width: 768px) {
            .trolens-header {
                padding: 12px 16px;
                flex-direction: row;
                justify-content: space-between;
                align-items: center;
            }
            
            .trolens-brand {
                font-size: 16px;
            }
            
            .trolens-tagline {
                font-size: 12px;
            }
            
            .version-badge {
                font-size: 10px;
                padding: 4px 8px;
            }
            
            .container {
                display: flex;
                flex-direction: column;
                height: calc(100vh - 60px);
            }
            
            .left-panel {
                order: 1;
                max-height: 120px;
                padding: 8px;
                overflow-x: auto;
                overflow-y: hidden;
                display: flex;
                flex-direction: row;
                gap: 8px;
            }
            
            .left-panel .element-group {
                min-width: 200px;
                flex-shrink: 0;
            }
            
            .canvas-container {
                order: 2;
                flex: 1;
                min-height: 300px;
                padding: 8px;
                display: flex;
                flex-direction: column;
            }
            
            .canvas {
                max-width: 100%;
                max-height: 100%;
                margin: auto;
            }
            
            .right-panel {
                order: 3;
                max-height: 200px;
                padding: 8px;
                overflow-y: auto;
            }
            
            .quick-actions {
                padding: 8px 12px;
                flex-wrap: wrap;
                gap: 6px;
                justify-content: center;
            }
            
            .quick-actions-buttons {
                gap: 6px;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .quick-action-btn {
                padding: 6px 10px;
                font-size: 10px;
                min-width: 60px;
            }
            
            .quick-action-btn span {
                font-size: 12px;
            }
        }

        /* Small Mobile Devices - Optimized for Phones */
        @media (max-width: 480px) {
            .trolens-header {
                padding: 8px 12px;
                flex-direction: column;
                gap: 4px;
                text-align: center;
            }
            
            .trolens-brand {
                font-size: 14px;
            }
            
            .trolens-tagline {
                font-size: 11px;
            }
            
            .version-badge {
                font-size: 9px;
                padding: 2px 6px;
            }
            
            .container {
                height: calc(100vh - 80px);
            }
            
            .left-panel {
                max-height: 100px;
                padding: 6px;
                gap: 6px;
            }
            
            .left-panel .element-group {
                min-width: 180px;
            }
            
            .element-btn {
                padding: 10px 8px;
                font-size: 10px;
                min-height: 50px;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
            }
            
            .element-icon {
                font-size: 18px;
            }
            
            .canvas-container {
                min-height: 250px;
                padding: 6px;
            }
            
            .canvas {
                max-width: 90%;
                max-height: 90%;
            }
            
            .right-panel {
                max-height: 180px;
                padding: 6px;
            }
            
            .property-group h3 {
                font-size: 13px;
                margin-bottom: 8px;
            }
            
            .property-row {
                flex-direction: column;
                gap: 6px;
                margin-bottom: 8px;
            }
            
            .property-row > div {
                width: 100%;
            }
            
            input, select, textarea {
                font-size: 16px;
                padding: 8px 10px;
                min-height: 44px;
                border-radius: 6px;
            }
            
            .quick-actions {
                padding: 6px 8px;
                gap: 4px;
            }
            
            .quick-action-btn {
                padding: 8px 6px;
                font-size: 9px;
                min-width: 50px;
                min-height: 36px;
            }
            
            .quick-action-btn span {
                font-size: 11px;
            }
        }

        /* Mobile Navigation Tabs */
        .mobile-nav {
            display: none;
            background: #2a2a3a;
            border-bottom: 1px solid #3a3a4a;
            padding: 8px;
        }
        
        .mobile-nav-tabs {
            display: flex;
            gap: 4px;
        }
        
        .mobile-nav-tab {
            flex: 1;
            padding: 8px 12px;
            background: #3a3a4a;
            border: none;
            border-radius: 6px;
            color: #ffffff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .mobile-nav-tab.active {
            background: #ff6b35;
        }
        
        @media (max-width: 768px) {
            .mobile-nav {
                display: block;
            }
            
            .left-panel, .right-panel {
                display: none;
            }
            
            .left-panel.mobile-active, .right-panel.mobile-active {
                display: block;
            }
        }

        /* Touch Device Optimizations */
        @media (hover: none) and (pointer: coarse) {
            .element-btn:hover {
                transform: none;
                box-shadow: none;
            }
            
            .quick-action-btn:hover {
                transform: none;
                box-shadow: none;
            }
            
            .quick-action-btn:active {
                transform: scale(0.95);
            }
            
            .element-btn:active {
                transform: scale(0.95);
            }
            
            /* Larger touch targets */
            .element-btn {
                min-height: 50px;
                min-width: 50px;
            }
            
            .quick-action-btn {
                min-height: 40px;
                min-width: 40px;
            }
            
            input, select, textarea {
                min-height: 48px;
                font-size: 16px; /* Prevents zoom on iOS */
            }
        }

        /* Landscape Mobile */
        @media (max-width: 900px) and (orientation: landscape) {
            .container {
                grid-template-rows: auto 1fr auto;
            }
            
            .left-panel, .right-panel {
                max-height: 120px;
            }
            
            .canvas-container {
                min-height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- Trolens Brand Header -->
    <div class="trolens-header">
        <div class="trolens-logo">
            <div class="trolens-avatar">
                <img src="https://cdn.discordapp.com/avatars/1011787830567120898/51b35a89cc0046bd8720770163fe680f.png" 
                     alt="Trolens Avatar" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div class="avatar-fallback">T</div>
            </div>
            <div>
                <div class="trolens-brand">Designed By Trolens</div>
                <div class="trolens-tagline">Cookie API Card Builder</div>
            </div>
        </div>
        <div class="version-badge">v3.0</div>
    </div>
    
    <!-- Mobile Navigation -->
    <div class="mobile-nav">
        <div class="mobile-nav-tabs">
            <button class="mobile-nav-tab active" onclick="showMobilePanel('elements')">Elements</button>
            <button class="mobile-nav-tab" onclick="showMobilePanel('canvas')">Canvas</button>
            <button class="mobile-nav-tab" onclick="showMobilePanel('properties')">Properties</button>
        </div>
    </div>

    <div class="container">
        <!-- Left Panel - Elements -->
        <div class="left-panel mobile-active" id="elements-panel">
            <div class="panel-title">Elements</div>
            
            <div class="element-group">
                <h3>Basic Elements</h3>
                <button class="element-btn" onclick="addElement('text')">
                    <div class="element-icon">T</div>
                    Text
                    <span class="quota" id="quota-text">0/100</span>
                </button>
                <button class="element-btn" onclick="addElement('image')">
                    <div class="element-icon">🖼</div>
                    Image
                    <span class="quota" id="quota-image">0/10</span>
                </button>
            </div>

            <div class="element-group">
                <h3>Profiles</h3>
                <button class="element-btn" onclick="addElement('discord_profile')">
                    <div class="element-icon">💬</div>
                    Discord Profile
                    <span class="quota" id="quota-discord">0/10</span>
                </button>
                <button class="element-btn" onclick="addElement('roblox_profile')">
                    <div class="element-icon">🎮</div>
                    Roblox Profile
                    <span class="quota" id="quota-roblox">0/10</span>
                </button>
            </div>

            <div class="element-group">
                <h3>Advanced</h3>
                <button class="element-btn" onclick="addElement('progressbar')">
                    <div class="element-icon">📊</div>
                    Progress Bar
                    <span class="quota" id="quota-progressbar">0/1</span>
                </button>
            </div>
        </div>

        <!-- Center Panel - Canvas -->
        <div class="center-panel">
            <div class="canvas-header">
                <div class="canvas-title">Card Canvas</div>
                <div class="canvas-controls">
                    <div class="control-group">
                        <label>Width:</label>
                        <input type="number" id="card-width" value="800" min="10" max="2000">
                    </div>
                    <div class="control-group">
                        <label>Height:</label>
                        <input type="number" id="card-height" value="400" min="10" max="2000">
                    </div>
                    <div class="control-group">
                        <label>Zoom:</label>
                        <select id="canvas-zoom">
                            <option value="0.25">25%</option>
                            <option value="0.5">50%</option>
                            <option value="0.75">75%</option>
                            <option value="1" selected>100%</option>
                            <option value="1.25">125%</option>
                            <option value="1.5">150%</option>
                            <option value="2.0">200%</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="quick-actions">
                <div class="quick-actions-title">Quick Actions</div>
                <div class="quick-actions-buttons">
                    <button class="quick-action-btn" onclick="centerElement()" title="Center Element">
                        <span>🎯</span> Center
                    </button>
                    <button class="quick-action-btn" onclick="alignElement('top')" title="Align to Top">
                        <span>⬆️</span> Top
                    </button>
                    <button class="quick-action-btn" onclick="alignElement('bottom')" title="Align to Bottom">
                        <span>⬇️</span> Bottom
                    </button>
                    <button class="quick-action-btn" onclick="alignElement('left')" title="Align to Left">
                        <span>⬅️</span> Left
                    </button>
                    <button class="quick-action-btn" onclick="alignElement('right')" title="Align to Right">
                        <span>➡️</span> Right
                    </button>
                    <button class="quick-action-btn" onclick="fitToCanvas()" title="Fit Element to Canvas">
                        <span>📐</span> Fit
                    </button>
                    <button class="quick-action-btn" onclick="resetPosition()" title="Reset Position">
                        <span>🔄</span> Reset
                    </button>
                </div>
            </div>
            <div class="canvas-container" id="canvas-panel">
                <div class="canvas" id="canvas">
                    <div class="canvas-resize-handle" id="canvas-resize-handle"></div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div class="right-panel" id="properties-panel">
            <div class="panel-title">Properties</div>
            
            <div id="card-properties">
                <div class="property-group">
                    <h3>Card Settings</h3>
                    <div class="property-row single">
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="bg-transparent" style="width: auto; margin: 0;">
                                <span>Transparent Background</span>
                            </label>
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Background Type</label>
                            <select id="bg-type">
                                <option value="color">Color</option>
                                <option value="image">Image URL</option>
                            </select>
                        </div>
                        <div id="color-picker-container">
                            <label>Background</label>
                            <input type="color" id="bg-color" value="#1a1a2a">
                        </div>
                    </div>
                    <div class="property-row single">
                        <div id="image-url-container">
                            <label>Background Image URL</label>
                            <input type="url" id="bg-image" placeholder="https://example.com/image.png">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Layers Panel -->
            <div class="property-group">
                <h3>Layers</h3>
                <div id="layers-list" class="layers-list">
                    <div class="no-layers">No elements added yet</div>
                </div>
            </div>

            <div id="element-properties" style="display: none;">
                <div class="property-group">
                    <h3>Element Properties</h3>
                    <div class="property-row">
                        <div>
                            <label>X Position</label>
                            <input type="number" id="prop-x" step="0.1">
                        </div>
                        <div>
                            <label>Y Position</label>
                            <input type="number" id="prop-y" step="0.1">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Width</label>
                            <div style="display: flex; gap: 4px; align-items: center;">
                                <input type="checkbox" id="prop-width-auto" style="width: auto;">
                                <label for="prop-width-auto" style="font-size: 10px; margin: 0;">Auto</label>
                                <input type="number" id="prop-width" step="0.1" style="flex: 1;">
                            </div>
                        </div>
                        <div>
                            <label>Height</label>
                            <input type="number" id="prop-height" step="0.1">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Opacity</label>
                            <input type="range" id="prop-opacity" min="0" max="100" value="100">
                        </div>
                        <div>
                            <label>Layer</label>
                            <input type="number" id="prop-layer" value="1">
                        </div>
                    </div>
                </div>

                <div id="text-properties" class="property-group" style="display: none;">
                    <h3>Text Properties</h3>
                    <div class="property-row single">
                        <div>
                            <label>Text Content</label>
                            <textarea id="prop-text" rows="3"></textarea>
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Font Size</label>
                            <input type="number" id="prop-font-size" value="16">
                        </div>
                        <div>
                            <label>Font Family</label>
                            <input type="text" id="prop-font-family" value="DM Sans" placeholder="DM Sans, Roboto, Open Sans, etc.">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Text Color</label>
                            <input type="color" id="prop-text-color" value="#ffffff">
                        </div>
                        <div>
                            <label>Text Align</label>
                            <select id="prop-text-align">
                                <option value="left">Left</option>
                                <option value="center">Center</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="image-properties" class="property-group" style="display: none;">
                    <h3>Image Properties</h3>
                    <div class="property-row single">
                        <div>
                            <label>Image URL</label>
                            <input type="url" id="prop-image-url" placeholder="https://example.com/image.png">
                        </div>
                    </div>
                </div>

                <div id="profile-properties" class="property-group" style="display: none;">
                    <h3>Profile Properties</h3>
                    <div class="property-row">
                        <div>
                            <label id="prop-name-label">Username</label>
                            <input type="text" id="prop-name" placeholder="Username">
                        </div>
                        <div>
                            <label>Auto Width</label>
                            <input type="checkbox" id="prop-profile-auto-width" checked>
                        </div>
                        <div>
                            <label>Border Radius</label>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <input type="range" id="prop-subtitle-slider" min="0" max="50" value="0" style="flex: 1;">
                                <input type="number" id="prop-subtitle" placeholder="0" min="0" max="50" style="width: 60px;">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="progress-properties" class="property-group" style="display: none;">
                    <h3>Progress Properties</h3>
                    <div class="property-row">
                        <div>
                            <label>Value</label>
                            <input type="number" id="prop-progress-value" min="0" value="60">
                        </div>
                        <div>
                            <label>Max Value</label>
                            <input type="number" id="prop-progress-max" min="1" value="100">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Bar Color</label>
                            <input type="color" id="prop-progress-color" value="#ff6b35">
                        </div>
                        <div>
                            <label>Background Color</label>
                            <input type="color" id="prop-progress-bg-color" value="#333333">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Border Radius</label>
                            <input type="number" id="prop-progress-border-radius" min="0" value="0">
                        </div>
                        <div></div>
                    </div>
                </div>


                <div class="property-group">
                    <button class="copy-btn" onclick="deleteElement()" style="background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%);">
                        Delete Element
                    </button>
                </div>
            </div>

            <div class="json-output">
                <h3>JSON Output</h3>
                <textarea class="json-textarea" id="json-output" readonly></textarea>
                <div style="display: flex; gap: 8px; margin-top: 6px;">
                    <button class="copy-btn" onclick="copyJSON()" style="flex: 1;">Copy JSON</button>
                    <button class="copy-btn" onclick="showUsageGuide()" style="background: linear-gradient(135deg, #4a4a5a 0%, #3a3a4a 100%); flex: 1;">How to Use</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Usage Guide Modal -->
    <div id="usage-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🤖 How to Use with Discord Bots</h2>
                <button class="modal-close" onclick="closeUsageGuide()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="guide-section">
                    <h3>📋 Step 1: Get Cookie API Access</h3>
                    <ol>
                        <li>Visit <a href="https://www.cookie-api.com" target="_blank">Cookie API</a> and sign up</li>
                        <li>Create an API key in your dashboard</li>
                        <li>Copy your API key for bot configuration</li>
                    </ol>
                </div>

                <div class="guide-section">
                    <h3>🔧 Step 2: API Configuration</h3>
                    <div class="code-block">
                        <strong>Base URL:</strong> <code>https://api.cookie-api.com/api/cards/card-builder/build</code><br>
                        <strong>Method:</strong> <code>POST</code><br>
                        <strong>Header Key:</strong> <code>Authorization</code><br>
                        <strong>Header Value:</strong> <code>COOKIE_API_KEY</code>
                    </div>
                </div>

                <div class="guide-section">
                    <h3>🤖 Step 3: Bot Integration</h3>
                    <p>Integrate this with your Discord bot using the API configuration above.</p>
                    <p>Use the <strong>HTTP Request</strong> or <strong>API Call</strong> block in your bot platform with the configuration above.</p>
                </div>

                <div class="guide-section">
                    <h3>⚡ Quick Start</h3>
                    <ol>
                        <li><strong>Design:</strong> Use this visual builder to create your card</li>
                        <li><strong>Copy:</strong> Click "Copy JSON" to get the card data</li>
                        <li><strong>Configure:</strong> Set up HTTP Request block in your bot builder</li>
                        <li><strong>Test:</strong> Send a command to generate your card!</li>
                    </ol>
                </div>

                <div class="guide-section">
                    <h3>📋 Element Limits</h3>
                    <div class="code-block">
                        <strong>Image:</strong> 10 images<br>
                        <strong>Text:</strong> 100 text fields with up to 100 unique fonts<br>
                        <strong>Discord Profile:</strong> 10 Discord profiles<br>
                        <strong>Roblox Profile:</strong> 10 Roblox profiles<br>
                        <strong>Progress Bar:</strong> 1 progress bar
                    </div>
                </div>

                <div class="guide-section">
                    <h3>⚠️ Important Notes</h3>
                    <ul>
                        <li>All generated cards count towards your storage</li>
                        <li>Cards will auto delete after <strong>7 days</strong></li>
                        <li>Both "card" and "elements" blocks are required in every request</li>
                    </ul>
                </div>

                <div class="guide-section">
                    <h3>🔗 Important Links</h3>
                    <ul>
                        <li><a href="https://www.cookie-api.com" target="_blank">Cookie API Website</a></li>
                        <li><a href="https://docs.cookie-api.com/en/docs/card-builder/overview" target="_blank">Card Builder Documentation</a></li>
                        <li><a href="https://docs.cookie-api.com/en/docs/card-builder/elements" target="_blank">Elements Documentation</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let elements = [];
        let selectedElement = null;
        let elementIdCounter = 1;
        
        // Card element (always exists)
        const cardElement = {
            id: 'card',
            type: 'card',
            name: 'Card',
            width: 800,
            height: 400,
            bg: '#1a1a2a',
            bg_type: 'color',
            bg_image: '',
            bg_transparent: false
        };

        // Limits
        const LIMITS = {
            text: 100,
            image: 10,
            discord_profile: 10,
            roblox_profile: 10,
            progressbar: 1
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Select Card by default
            selectedElement = 'card';
            
            updateCanvas();
            updateQuotas();
            updateJSON();
            updateQuickActionsState();
            updateLayersPanel();
            updateCardProperties();
            initCanvasResize();
            
            // Card property listeners
            document.getElementById('card-width').addEventListener('input', function() {
                cardElement.width = parseInt(this.value);
                updateCanvas();
            });
            document.getElementById('card-height').addEventListener('input', function() {
                cardElement.height = parseInt(this.value);
                updateCanvas();
            });
            const zoomSelect = document.getElementById('canvas-zoom');
            if (zoomSelect) {
                const handleZoomChange = function() {
                    console.log('Zoom changed to:', this.value);
                    updateCanvas();
                    updateJSON();
                };
                
                zoomSelect.addEventListener('change', handleZoomChange);
                zoomSelect.addEventListener('input', handleZoomChange);
                console.log('Zoom event listeners added successfully');
            } else {
                console.error('Canvas zoom select not found!');
            }
            document.getElementById('bg-type').addEventListener('change', function() {
                cardElement.bg_type = this.value;
                handleBackgroundTypeChange();
            });
            document.getElementById('bg-color').addEventListener('input', function() {
                cardElement.bg = this.value;
                updateCanvas();
            });
            document.getElementById('bg-image').addEventListener('input', function() {
                cardElement.bg_image = this.value;
                updateCanvas();
            });
            document.getElementById('bg-transparent').addEventListener('change', function() {
                cardElement.bg_transparent = this.checked;
                handleTransparencyToggle();
            });
        });

        // Add element
        function addElement(type) {
            // Check if type is supported
            if (!LIMITS.hasOwnProperty(type)) {
                console.warn(`Element type '${type}' is not supported`);
                return;
            }
            
            if (elements.filter(e => e.type === type).length >= LIMITS[type]) {
                alert(`Limit reached for ${type} elements (${LIMITS[type]})`);
                return;
            }

            const element = {
                id: elementIdCounter++,
                type: type,
                x: 50,
                y: 50,
                width: type === 'text' ? 200 : (type === 'discord_profile' ? 50 : (type === 'roblox_profile' ? 'auto' : 100)),
                height: type === 'text' ? 30 : (type === 'discord_profile' ? 50 : 100),
                widthAuto: type === 'discord_profile' || type === 'roblox_profile' ? true : false,
                opacity: 100,
                layer: elements.length + 1,
                text: type === 'text' ? 'Sample Text' : '',
                fontSize: 16,
                fontFamily: 'DM Sans',
                textColor: '#ffffff',
                textAlign: 'left',
                imageUrl: '',
                avatarUrl: '',
                name: '',
                subtitle: 'Status',
                userId: type === 'discord_profile' ? '1011787830567120898' : undefined,
                borderRadius: type === 'discord_profile' ? 0 : undefined,
                user: type === 'roblox_profile' ? '' : undefined,
                transparency: type === 'roblox_profile' ? '100' : undefined,
                progressValue: 60,
                progressMax: 100,
                progressColor: '#ff6b35',
                progressBgColor: '#333333',
                progressBorderRadius: 0,
                shapeFill: '#ff6b35',
                shapeRadius: 8
            };

            elements.push(element);
            updateCanvas();
            updateQuotas();
            updateJSON();
            selectElement(element.id);
        }

        // Handle background type change
        function handleBackgroundTypeChange() {
            const bgType = document.getElementById('bg-type').value;
            const colorPickerContainer = document.getElementById('color-picker-container');
            const imageUrlContainer = document.getElementById('image-url-container');
            
            if (bgType === 'image') {
                // Hide color picker, show image URL
                colorPickerContainer.style.display = 'none';
                imageUrlContainer.style.display = 'block';
            } else {
                // Show color picker, hide image URL
                colorPickerContainer.style.display = 'block';
                imageUrlContainer.style.display = 'none';
            }
            
            // Update canvas and JSON
            updateCanvas();
            updateJSON();
        }

        // Handle transparency toggle
        function handleTransparencyToggle() {
            const isTransparent = document.getElementById('bg-transparent').checked;
            const bgTypeSelect = document.getElementById('bg-type');
            const bgColorInput = document.getElementById('bg-color');
            const bgImageInput = document.getElementById('bg-image');
            const colorPickerContainer = document.getElementById('color-picker-container');
            const imageUrlContainer = document.getElementById('image-url-container');
            
            if (isTransparent) {
                // Hide all background controls when transparent
                bgTypeSelect.disabled = true;
                bgColorInput.disabled = true;
                bgImageInput.disabled = true;
                colorPickerContainer.style.display = 'none';
                imageUrlContainer.style.display = 'none';
            } else {
                // Re-enable background type selector
                bgTypeSelect.disabled = false;
                // Handle background type visibility
                handleBackgroundTypeChange();
            }
            
            // Update canvas and JSON
            updateCanvas();
            updateJSON();
        }

        // Update canvas
        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const width = cardElement.width;
            const height = cardElement.height;
            const zoom = parseFloat(document.getElementById('canvas-zoom').value);
            
            const newWidth = (width * zoom) + 'px';
            const newHeight = (height * zoom) + 'px';
            
            console.log('Updating canvas size:', { width, height, zoom, newWidth, newHeight });
            
            canvas.style.width = newWidth;
            canvas.style.height = newHeight;
            
            // Handle transparency
            const isTransparent = cardElement.bg_transparent;
            
            if (isTransparent) {
                canvas.classList.add('transparent');
                // Remove any inline background styles to let CSS handle the pattern
                canvas.style.background = '';
                canvas.style.backgroundImage = '';
            } else {
                canvas.classList.remove('transparent');
                // Set background
                if (cardElement.bg_type === 'color') {
                    canvas.style.background = cardElement.bg;
                } else {
                    canvas.style.background = cardElement.bg_image ? `url(${cardElement.bg_image}) center/cover` : '#1a1a2a';
                }
            }
            
            // Clear canvas but preserve resize handle
            const resizeHandle = canvas.querySelector('.canvas-resize-handle');
            canvas.innerHTML = '';
            if (resizeHandle) {
                canvas.appendChild(resizeHandle);
            }
            
            // Render elements
            const sortedElements = [...elements].sort((a, b) => a.layer - b.layer);
            sortedElements.forEach(element => {
                const elementDiv = createElementDiv(element, zoom);
                canvas.appendChild(elementDiv);
            });
            
            // Update layers panel
            updateLayersPanel();
            
            // Ensure resize handle is always present
            ensureResizeHandle();
        }

        // Ensure resize handle exists
        function ensureResizeHandle() {
            const canvas = document.getElementById('canvas');
            let resizeHandle = canvas.querySelector('.canvas-resize-handle');
            
            if (!resizeHandle) {
                resizeHandle = document.createElement('div');
                resizeHandle.id = 'canvas-resize-handle';
                resizeHandle.className = 'canvas-resize-handle';
                canvas.appendChild(resizeHandle);
                console.log('Resize handle recreated');
                
                // Re-initialize resize functionality
                setTimeout(() => {
                    initCanvasResize();
                }, 100);
            }
        }

        // Create element div
        function createElementDiv(element, zoom) {
            const div = document.createElement('div');
            div.className = 'canvas-element';
            div.dataset.id = element.id;
            
            if (selectedElement === element.id) {
                div.classList.add('selected');
            }
            
            div.style.left = (element.x * zoom) + 'px';
            div.style.top = (element.y * zoom) + 'px';
            
            // Handle auto width
            if (element.widthAuto || element.width === 'auto') {
                div.style.width = (element.height * zoom) + 'px'; // Make width equal to height for square elements
            } else {
                div.style.width = (element.width * zoom) + 'px';
            }
            div.style.height = (element.height * zoom) + 'px';
            div.style.opacity = element.opacity / 100;
            
            // Create content based on type
            let content = '';
            try {
                if (element.type === 'text') {
                content = `<div style="
                    font-family: ${element.fontFamily};
                    font-size: ${element.fontSize * zoom}px;
                    color: ${element.textColor};
                    text-align: ${element.textAlign};
                    padding: 4px;
                    white-space: pre-wrap;
                ">${element.text}</div>`;
            } else if (element.type === 'image') {
                if (element.imageUrl && element.imageUrl.trim() !== '') {
                    content = `<img src="${element.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" onerror="if(this) this.style.display='none'">`;
                } else {
                    content = `<div style="
                        width: 100%;
                        height: 100%;
                        background: #f0f0f0;
                        border: 2px dashed #ccc;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: #666;
                        font-size: 12px;
                        text-align: center;
                        padding: 8px;
                        box-sizing: border-box;
                    ">
                        <div style="font-size: 24px; margin-bottom: 8px;">🖼️</div>
                        <div>Please fill the URL</div>
                    </div>`;
                }
            } else if (element.type === 'discord_profile') {
                const borderRadius = 50 - (element.borderRadius || 0);
                const userId = element.userId;
                
                if (userId && userId.trim() !== '') {
                    // Check if it's your User ID
                    const isYourId = userId === '1011787830567120898';
                    
                    let avatarUrl;
                    if (isYourId) {
                        // Your actual avatar
                        avatarUrl = `https://cdn.discordapp.com/avatars/1011787830567120898/51b35a89cc0046bd8720770163fe680f.png`;
                    } else {
                        // Default avatar for other users
                        const defaultIndex = parseInt(userId) % 5;
                        avatarUrl = `https://cdn.discordapp.com/embed/avatars/${defaultIndex}.png`;
                    }
                    
                    content = `<img src="${avatarUrl}" 
                        style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: ${borderRadius}%;
                        " 
                        onerror="this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex';"
                    >
                    <div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: #5865f2;
                        display: none;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 14px;
                    ">D</div>`;
                } else {
                    content = `<div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: #5865f2;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 14px;
                    ">D</div>`;
                }
            } else if (element.type === 'roblox_profile') {
                const borderRadius = 50 - (element.borderRadius || 0);
                const username = element.name;
                
                if (username && username.trim() !== '') {
                    // Use Roblox avatar API - this requires user ID, not username
                    // For now, we'll use a placeholder that shows the username was entered
                    const avatarUrl = `https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=${username}&size=150x150&format=Png`;
                    content = `<img src="${avatarUrl}" 
                        style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: ${borderRadius}%;
                        " 
                        onerror="this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex';"
                    >
                    <div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: linear-gradient(135deg, #00a2ff 0%, #00d4ff 100%);
                        display: none;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                    ">R</div>`;
                } else {
                    // Default Roblox app icon
                    content = `<img src="https://static.wikia.nocookie.net/logopedia/images/d/d6/Roblox_app_icon_2022.svg/revision/latest/scale-to-width-down/250?cb=20220319140506" 
                        style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: ${borderRadius}%;
                        " 
                        onerror="this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex';"
                    >
                    <div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: linear-gradient(135deg, #00a2ff 0%, #00d4ff 100%);
                        display: none;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                    ">R</div>`;
                }
            } else if (element.type === 'progressbar') {
                const progressPercent = (element.progressValue / element.progressMax) * 100;
                content = `<div style="
                    width: 100%;
                    height: 100%;
                    background: ${element.progressBgColor};
                    border-radius: ${element.progressBorderRadius}px;
                    overflow: hidden;
                ">
                    <div style="
                        width: ${progressPercent}%;
                        height: 100%;
                        background: ${element.progressColor};
                        transition: width 0.3s ease;
                    "></div>
                </div>`;
            } else if (element.type === 'shape') {
                content = `<div style="
                    width: 100%;
                    height: 100%;
                    background: ${element.shapeFill};
                    border-radius: ${element.shapeRadius}px;
                "></div>`;
            }
            } catch (error) {
                console.error('Error rendering element:', error);
                content = `<div style="
                    width: 100%;
                    height: 100%;
                    background: #ff4757;
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                ">Error</div>`;
            }
            
            div.innerHTML = content;
            
            // Add resize handles
            if (selectedElement === element.id) {
                div.innerHTML += `
                    <div class="resize-handle nw"></div>
                    <div class="resize-handle ne"></div>
                    <div class="resize-handle sw"></div>
                    <div class="resize-handle se"></div>
                `;
            }
            
            // Add event listeners
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                selectElement(element.id);
            });
            
            div.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) {
                    e.stopPropagation();
                    startResize(element.id, e.target.className.split(' ')[1]);
                } else {
                    e.stopPropagation();
                    // Clean up any existing drag listeners before starting new drag
                    cleanupDragListeners();
                    startDrag(element.id, e);
                }
            });
            
            return div;
        }

        // Select element
        function selectElement(id) {
            selectedElement = id;
            updateCanvas();
            updateElementProperties();
            updateQuickActionsState();
            
            // If selecting card, update card properties
            if (id === 'card') {
                updateCardProperties();
            }
        }

        // Update card properties panel
        function updateCardProperties() {
            // Show card properties instead of element properties
            const cardPropertiesPanel = document.getElementById('card-properties');
            const elementPropertiesPanel = document.getElementById('element-properties');
            
            if (cardPropertiesPanel && elementPropertiesPanel) {
                cardPropertiesPanel.style.display = 'block';
                elementPropertiesPanel.style.display = 'none';
            }
            
            // Update card property values
            const widthInput = document.getElementById('card-width');
            const heightInput = document.getElementById('card-height');
            const bgTypeSelect = document.getElementById('bg-type');
            const bgColorInput = document.getElementById('bg-color');
            const bgImageInput = document.getElementById('bg-image');
            const bgTransparentCheckbox = document.getElementById('bg-transparent');
            
            if (widthInput) widthInput.value = cardElement.width;
            if (heightInput) heightInput.value = cardElement.height;
            if (bgTypeSelect) bgTypeSelect.value = cardElement.bg_type;
            if (bgColorInput) bgColorInput.value = cardElement.bg;
            if (bgImageInput) bgImageInput.value = cardElement.bg_image;
            if (bgTransparentCheckbox) bgTransparentCheckbox.checked = cardElement.bg_transparent;
        }

        // Update element properties panel
        function updateElementProperties() {
            if (selectedElement === 'card') {
                updateCardProperties();
                return;
            }
            
            const element = elements.find(e => e.id === selectedElement);
            if (!element) {
                document.getElementById('element-properties').style.display = 'none';
                document.getElementById('card-properties').style.display = 'block';
                return;
            }
            
            document.getElementById('element-properties').style.display = 'block';
            document.getElementById('card-properties').style.display = 'none';
            
            // Update property fields with current values
            document.getElementById('prop-x').value = element.x;
            document.getElementById('prop-y').value = element.y;
            document.getElementById('prop-width').value = element.width;
            document.getElementById('prop-height').value = element.height;
            document.getElementById('prop-opacity').value = element.opacity;
            document.getElementById('prop-layer').value = element.layer;
            
            // Update auto width checkbox
            const isAutoWidth = element.widthAuto || element.width === 'auto';
            document.getElementById('prop-width-auto').checked = isAutoWidth;
            document.getElementById('prop-width').disabled = isAutoWidth;
            
            // If auto width, show the height value in width field for reference
            if (isAutoWidth) {
                document.getElementById('prop-width').value = element.height;
            }
            
            // Show/hide type-specific properties
            const textProps = document.getElementById('text-properties');
            const imageProps = document.getElementById('image-properties');
            const profileProps = document.getElementById('profile-properties');
            const progressProps = document.getElementById('progress-properties');
            const shapeProps = document.getElementById('shape-properties');
            
            if (textProps) textProps.style.display = element.type === 'text' ? 'block' : 'none';
            if (imageProps) imageProps.style.display = element.type === 'image' ? 'block' : 'none';
            if (profileProps) profileProps.style.display = (element.type === 'discord_profile' || element.type === 'roblox_profile') ? 'block' : 'none';
            if (progressProps) progressProps.style.display = element.type === 'progressbar' ? 'block' : 'none';
            if (shapeProps) shapeProps.style.display = element.type === 'shape' ? 'block' : 'none';
            
            // Hide position and height fields for both Discord and Roblox profiles
            // But keep the width row visible (we'll hide just the input field later)
            const positionFields = document.querySelectorAll('#prop-x, #prop-y, #prop-height');
            positionFields.forEach(field => {
                if (field) {
                    const row = field.closest('.property-row');
                    if (row) {
                        if (element.type === 'discord_profile' || element.type === 'roblox_profile') {
                            row.style.display = 'none';
                        } else {
                            row.style.display = 'flex';
                        }
                    }
                }
            });
            
            // For profile types, hide only the width input field but keep the auto checkbox visible
            const widthInput = document.getElementById('prop-width');
            const autoCheckbox = document.getElementById('prop-width-auto');
            
            if (element.type === 'discord_profile' || element.type === 'roblox_profile') {
                // Hide the width input field but keep the auto checkbox visible
                if (widthInput) widthInput.style.display = 'none';
                if (autoCheckbox) autoCheckbox.style.display = 'inline-block';
            } else {
                // Show both for other element types
                if (widthInput) widthInput.style.display = 'block';
                if (autoCheckbox) autoCheckbox.style.display = 'inline-block';
            }
            
            // Update type-specific fields
            if (element.type === 'text') {
                const propText = document.getElementById('prop-text');
                const propFontSize = document.getElementById('prop-font-size');
                const propFontFamily = document.getElementById('prop-font-family');
                const propTextColor = document.getElementById('prop-text-color');
                const propTextAlign = document.getElementById('prop-text-align');
                
                if (propText) propText.value = element.text;
                if (propFontSize) propFontSize.value = element.fontSize;
                if (propFontFamily) propFontFamily.value = element.fontFamily;
                if (propTextColor) propTextColor.value = element.textColor;
                if (propTextAlign) propTextAlign.value = element.textAlign;
            } else if (element.type === 'image') {
                const propImageUrl = document.getElementById('prop-image-url');
                if (propImageUrl) propImageUrl.value = element.imageUrl;
            } else if (element.type === 'discord_profile') {
                const propName = document.getElementById('prop-name');
                const propNameLabel = document.getElementById('prop-name-label');
                const propSubtitle = document.getElementById('prop-subtitle');
                const propSubtitleSlider = document.getElementById('prop-subtitle-slider');
                
                if (propNameLabel) propNameLabel.textContent = 'Discord ID';
                if (propName) {
                    propName.value = element.userId || '';
                    propName.placeholder = '1011787830567120898';
                }
                if (propSubtitle) propSubtitle.value = element.borderRadius || 0;
                if (propSubtitleSlider) propSubtitleSlider.value = element.borderRadius || 0;
                const profileAutoWidth = document.getElementById('prop-profile-auto-width');
                if (profileAutoWidth) {
                    profileAutoWidth.checked = element.widthAuto || element.width === 'auto';
                    // Update the element state to match the checkbox
                    element.widthAuto = profileAutoWidth.checked;
                }
            } else if (element.type === 'roblox_profile') {
                const propName = document.getElementById('prop-name');
                const propNameLabel = document.getElementById('prop-name-label');
                const propSubtitle = document.getElementById('prop-subtitle');
                const propSubtitleSlider = document.getElementById('prop-subtitle-slider');
                
                if (propNameLabel) propNameLabel.textContent = 'Username';
                if (propName) {
                    propName.value = element.name || '';
                    propName.placeholder = 'redxxxkiller';
                }
                if (propSubtitle) propSubtitle.value = element.borderRadius || 0;
                if (propSubtitleSlider) propSubtitleSlider.value = element.borderRadius || 0;
                const profileAutoWidth = document.getElementById('prop-profile-auto-width');
                if (profileAutoWidth) {
                    profileAutoWidth.checked = element.widthAuto || element.width === 'auto';
                    // Update the element state to match the checkbox
                    element.widthAuto = profileAutoWidth.checked;
                }
            } else if (element.type === 'progressbar') {
                const propProgressValue = document.getElementById('prop-progress-value');
                const propProgressMax = document.getElementById('prop-progress-max');
                const propProgressColor = document.getElementById('prop-progress-color');
                const propProgressBgColor = document.getElementById('prop-progress-bg-color');
                const propProgressBorderRadius = document.getElementById('prop-progress-border-radius');
                
                if (propProgressValue) propProgressValue.value = element.progressValue;
                if (propProgressMax) propProgressMax.value = element.progressMax;
                if (propProgressColor) propProgressColor.value = element.progressColor;
                if (propProgressBgColor) propProgressBgColor.value = element.progressBgColor;
                if (propProgressBorderRadius) propProgressBorderRadius.value = element.progressBorderRadius;
            } else if (element.type === 'shape') {
                const propShapeFill = document.getElementById('prop-shape-fill');
                const propShapeRadius = document.getElementById('prop-shape-radius');
                
                if (propShapeFill) propShapeFill.value = element.shapeFill;
                if (propShapeRadius) propShapeRadius.value = element.shapeRadius;
            }
            
            // Add property change listeners
            addPropertyListeners();
        }

        // Add property change listeners
        function addPropertyListeners() {
            const element = elements.find(e => e.id === selectedElement);
            if (!element) return;
            
            // Basic properties
            document.getElementById('prop-x').oninput = () => {
                element.x = parseFloat(document.getElementById('prop-x').value);
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-y').oninput = () => {
                element.y = parseFloat(document.getElementById('prop-y').value);
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-width').oninput = () => {
                if (!document.getElementById('prop-width-auto').checked) {
                    element.width = parseFloat(document.getElementById('prop-width').value);
                    updateCanvas();
                    updateJSON();
                }
            };
            document.getElementById('prop-width-auto').onchange = () => {
                const isAuto = document.getElementById('prop-width-auto').checked;
                element.widthAuto = isAuto;
                document.getElementById('prop-width').disabled = isAuto;
                if (isAuto) {
                    element.width = 'auto';
                    // Show height value in width field for reference
                    document.getElementById('prop-width').value = element.height;
                } else {
                    element.width = parseFloat(document.getElementById('prop-width').value);
                }
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-height').oninput = () => {
                element.height = parseFloat(document.getElementById('prop-height').value);
                // If auto width is enabled, update the width field to show the new height
                if (element.widthAuto || element.width === 'auto') {
                    document.getElementById('prop-width').value = element.height;
                }
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-opacity').oninput = () => {
                element.opacity = parseInt(document.getElementById('prop-opacity').value);
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-layer').oninput = () => {
                element.layer = parseInt(document.getElementById('prop-layer').value);
                updateCanvas();
                updateJSON();
            };
            
            // Text properties
            if (element.type === 'text') {
                document.getElementById('prop-text').oninput = () => {
                    element.text = document.getElementById('prop-text').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-font-size').oninput = () => {
                    element.fontSize = parseInt(document.getElementById('prop-font-size').value);
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-font-family').oninput = () => {
                    element.fontFamily = document.getElementById('prop-font-family').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-text-color').oninput = () => {
                    element.textColor = document.getElementById('prop-text-color').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-text-align').onchange = () => {
                    element.textAlign = document.getElementById('prop-text-align').value;
                    updateCanvas();
                    updateJSON();
                };
            }
            
            // Image properties
            if (element.type === 'image') {
                document.getElementById('prop-image-url').oninput = () => {
                    element.imageUrl = document.getElementById('prop-image-url').value;
                    updateCanvas();
                    updateJSON();
                    // Update property values to reflect current position
                    updateElementProperties();
                };
            }
            
            // Profile properties
            if (element.type === 'discord_profile') {
                // Don't force widthAuto - let the checkbox control it
                
                document.getElementById('prop-name').oninput = () => {
                    const userId = document.getElementById('prop-name').value;
                    element.userId = userId;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle').oninput = () => {
                    const value = Math.min(Math.max(parseInt(document.getElementById('prop-subtitle').value) || 0, 0), 50);
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle-slider').value = value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle-slider').oninput = () => {
                    const value = parseInt(document.getElementById('prop-subtitle-slider').value);
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle').value = value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-profile-auto-width').onchange = () => {
                    const isAuto = document.getElementById('prop-profile-auto-width').checked;
                    element.widthAuto = isAuto;
                    if (isAuto) {
                        element.width = 'auto';
                    } else {
                        element.width = element.height; // Set to height for square when not auto
                    }
                    updateCanvas();
                    updateJSON();
                };
            } else if (element.type === 'roblox_profile') {
                document.getElementById('prop-name').oninput = () => {
                    const username = document.getElementById('prop-name').value;
                    element.name = username;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle').oninput = () => {
                    const value = Math.min(Math.max(parseInt(document.getElementById('prop-subtitle').value) || 0, 0), 50);
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle-slider').value = value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle-slider').oninput = () => {
                    const value = parseInt(document.getElementById('prop-subtitle-slider').value);
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle').value = value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-profile-auto-width').onchange = () => {
                    const isAuto = document.getElementById('prop-profile-auto-width').checked;
                    element.widthAuto = isAuto;
                    if (isAuto) {
                        element.width = 'auto';
                    } else {
                        element.width = element.height; // Set to height for square when not auto
                    }
                    updateCanvas();
                    updateJSON();
                };
            }
            
            // Progress properties
            if (element.type === 'progressbar') {
                document.getElementById('prop-progress-value').oninput = () => {
                    element.progressValue = parseInt(document.getElementById('prop-progress-value').value);
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-max').oninput = () => {
                    element.progressMax = parseInt(document.getElementById('prop-progress-max').value);
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-color').oninput = () => {
                    element.progressColor = document.getElementById('prop-progress-color').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-bg-color').oninput = () => {
                    element.progressBgColor = document.getElementById('prop-progress-bg-color').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-border-radius').oninput = () => {
                    element.progressBorderRadius = parseInt(document.getElementById('prop-progress-border-radius').value);
                    updateCanvas();
                    updateJSON();
                };
            }
            
            // Shape properties
            if (element.type === 'shape') {
                document.getElementById('prop-shape-fill').oninput = () => {
                    element.shapeFill = document.getElementById('prop-shape-fill').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-shape-radius').oninput = () => {
                    element.shapeRadius = parseInt(document.getElementById('prop-shape-radius').value);
                    updateCanvas();
                    updateJSON();
                };
            }
        }

        // Global cleanup function for drag listeners
        function cleanupDragListeners() {
            // Remove all potential drag-related event listeners
            const events = ['mousemove', 'mouseup', 'touchmove', 'touchend'];
            events.forEach(eventType => {
                // Create a dummy function to remove all listeners of this type
                const dummyHandler = () => {};
                document.removeEventListener(eventType, dummyHandler);
            });
        }

        // Add window blur listener to clean up drag listeners when user switches tabs
        window.addEventListener('blur', cleanupDragListeners);
        window.addEventListener('beforeunload', cleanupDragListeners);
        
        // Mobile touch optimizations
        function isMobileDevice() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   (navigator.maxTouchPoints && navigator.maxTouchPoints > 1);
        }
        
        // Mobile navigation
        function showMobilePanel(panel) {
            // Hide all panels
            document.getElementById('elements-panel').classList.remove('mobile-active');
            document.getElementById('canvas-panel').classList.remove('mobile-active');
            document.getElementById('properties-panel').classList.remove('mobile-active');
            
            // Remove active class from all tabs
            document.querySelectorAll('.mobile-nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected panel
            if (panel === 'elements') {
                document.getElementById('elements-panel').classList.add('mobile-active');
                document.querySelector('.mobile-nav-tab[onclick="showMobilePanel(\'elements\')"]').classList.add('active');
            } else if (panel === 'canvas') {
                document.getElementById('canvas-panel').classList.add('mobile-active');
                document.querySelector('.mobile-nav-tab[onclick="showMobilePanel(\'canvas\')"]').classList.add('active');
            } else if (panel === 'properties') {
                document.getElementById('properties-panel').classList.add('mobile-active');
                document.querySelector('.mobile-nav-tab[onclick="showMobilePanel(\'properties\')"]').classList.add('active');
            }
        }
        
        // Adjust canvas zoom for mobile
        if (isMobileDevice()) {
            const canvasZoom = document.getElementById('canvas-zoom');
            if (canvasZoom) {
                canvasZoom.value = '0.5'; // Default to 50% zoom on mobile
                updateCanvas();
            }
        }

        // Start drag
        function startDrag(id, e) {
            const element = elements.find(el => el.id === id);
            if (!element) return;
            
            // Handle both mouse and touch events
            const startX = e.clientX || (e.touches && e.touches[0].clientX);
            const startY = e.clientY || (e.touches && e.touches[0].clientY);
            const startElementX = element.x;
            const startElementY = element.y;
            const zoom = parseFloat(document.getElementById('canvas-zoom').value);
            
            // Prevent default to avoid text selection and scrolling
            e.preventDefault();
            
            function onMouseMove(e) {
                e.preventDefault();
                // Handle both mouse and touch events
                const currentX = e.clientX || (e.touches && e.touches[0].clientX);
                const currentY = e.clientY || (e.touches && e.touches[0].clientY);
                const deltaX = (currentX - startX) / zoom;
                const deltaY = (currentY - startY) / zoom;
                element.x = startElementX + deltaX;
                element.y = startElementY + deltaY;
                updateCanvas();
                updateElementProperties();
                updateJSON();
            }
            
            function onMouseUp(e) {
                e.preventDefault();
                // Clean up event listeners
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                // Also remove any potential touch events
                document.removeEventListener('touchmove', onMouseMove);
                document.removeEventListener('touchend', onMouseUp);
                
                // Restore scrolling on mobile
                if (isMobileDevice()) {
                    document.body.style.overflow = '';
                }
            }
            
            // Add event listeners with passive: false to allow preventDefault
            document.addEventListener('mousemove', onMouseMove, { passive: false });
            document.addEventListener('mouseup', onMouseUp, { passive: false });
            
            // Also handle touch events for mobile
            document.addEventListener('touchmove', onMouseMove, { passive: false });
            document.addEventListener('touchend', onMouseUp, { passive: false });
            
            // Prevent scrolling on mobile during drag
            if (isMobileDevice()) {
                document.body.style.overflow = 'hidden';
            }
        }

        // Start resize
        function startResize(id, direction) {
            const element = elements.find(el => el.id === id);
            const startX = event.clientX;
            const startY = event.clientY;
            const startElementX = element.x;
            const startElementY = element.y;
            const startWidth = element.width;
            const startHeight = element.height;
            const zoom = parseFloat(document.getElementById('canvas-zoom').value);
            
            function onMouseMove(e) {
                const deltaX = (e.clientX - startX) / zoom;
                const deltaY = (e.clientY - startY) / zoom;
                
                if (direction.includes('e')) {
                    element.width = Math.max(10, startWidth + deltaX);
                }
                if (direction.includes('w')) {
                    element.width = Math.max(10, startWidth - deltaX);
                    element.x = startElementX + deltaX;
                }
                if (direction.includes('s')) {
                    element.height = Math.max(10, startHeight + deltaY);
                }
                if (direction.includes('n')) {
                    element.height = Math.max(10, startHeight - deltaY);
                    element.y = startElementY + deltaY;
                }
                
                updateCanvas();
                updateElementProperties();
                updateJSON();
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // Delete element
        function deleteElement() {
            if (selectedElement) {
                elements = elements.filter(e => e.id !== selectedElement);
                selectedElement = null;
                updateCanvas();
                updateQuotas();
                updateJSON();
                updateElementProperties();
                updateQuickActionsState();
            }
        }

        // Update quotas
        function updateQuotas() {
        const counts = {
            text: elements.filter(e => e.type === 'text').length,
            image: elements.filter(e => e.type === 'image').length,
            discord_profile: elements.filter(e => e.type === 'discord_profile').length,
            roblox_profile: elements.filter(e => e.type === 'roblox_profile').length,
            progressbar: elements.filter(e => e.type === 'progressbar').length,
            shape: elements.filter(e => e.type === 'shape').length
        };
            
            Object.keys(counts).forEach(type => {
                const quotaEl = document.getElementById(`quota-${type}`);
                if (quotaEl) {
                    quotaEl.textContent = `${counts[type]}/${LIMITS[type]}`;
                }
            });
            
            // Update button states
            Object.keys(LIMITS).forEach(type => {
                const button = document.querySelector(`[onclick="addElement('${type}')"]`);
                if (button) {
                    const count = counts[type] || 0;
                    const limit = LIMITS[type];
                    button.disabled = count >= limit;
                }
            });
        }

        // Update layers panel
        function updateLayersPanel() {
            const layersList = document.getElementById('layers-list');
            
            // Always show Card element first
            const cardHtml = `
                <div class="layer-item card-layer ${selectedElement === 'card' ? 'selected' : ''}" data-id="card">
                    <div class="layer-icon">🖼️</div>
                    <div class="layer-info">
                        <div class="layer-name">Card</div>
                        <div class="layer-details">Canvas Properties</div>
                    </div>
                    <div class="layer-controls">
                        <button class="layer-btn" onclick="selectElement('card')" title="Select Card">✓</button>
                    </div>
                </div>
            `;
            
            // Add elements if any exist
            let elementsHtml = '';
            if (elements.length > 0) {
                const sortedElements = [...elements].sort((a, b) => b.layer - a.layer);
                elementsHtml = sortedElements.map(element => {
                    const icon = getElementIcon(element.type);
                    const name = getElementDisplayName(element);
                    const details = getElementDetails(element);
                    const isSelected = selectedElement === element.id;
                    
                    return `
                        <div class="layer-item ${isSelected ? 'selected' : ''}" data-id="${element.id}">
                            <div class="layer-icon">${icon}</div>
                            <div class="layer-info">
                                <div class="layer-name">${name}</div>
                                <div class="layer-details">${details}</div>
                            </div>
                            <div class="layer-controls">
                                <button class="layer-btn" onclick="moveLayerUp(${element.id})" title="Move Up">↑</button>
                                <button class="layer-btn" onclick="moveLayerDown(${element.id})" title="Move Down">↓</button>
                                <button class="layer-btn delete" onclick="deleteElementFromLayer(${element.id})" title="Delete">×</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            layersList.innerHTML = cardHtml + elementsHtml;
            
            // Add click listeners to layer items
            layersList.querySelectorAll('.layer-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('layer-btn')) {
                        const id = parseInt(item.dataset.id);
                        selectElement(id);
                    }
                });
            });
        }

        // Get element icon
        function getElementIcon(type) {
            const icons = {
                text: 'T',
                image: '🖼',
                discord_profile: '💬',
                roblox_profile: '🎮',
                progressbar: '📊',
                shape: '⬜'
            };
            return icons[type] || '?';
        }

        // Get element display name
        function getElementDisplayName(element) {
            if (element.type === 'text') {
                return element.text || 'Text';
            } else if (element.type === 'image') {
                return 'Image';
            } else if (element.type === 'discord_profile') {
                return element.userId ? `Discord (${element.userId})` : 'Discord Profile';
            } else if (element.type === 'roblox_profile') {
                return element.name ? 'Roblox User' : 'Roblox Profile';
            } else if (element.type === 'progressbar') {
                return `Progress (${element.progressValue}/${element.progressMax})`;
            } else if (element.type === 'shape') {
                return 'Shape';
            }
            return element.type;
        }

        // Get element details
        function getElementDetails(element) {
            if (element.type === 'text') {
                return `${element.fontSize}px ${element.fontFamily}`;
            } else if (element.type === 'image') {
                return `${Math.round(element.width)}×${Math.round(element.height)}`;
            } else if (element.type === 'discord_profile') {
                return `Radius: ${element.borderRadius || 100}`;
            } else if (element.type === 'roblox_profile') {
                return element.subtitle || 'Profile';
            } else if (element.type === 'progressbar') {
                return `${Math.round(element.width)}×${Math.round(element.height)}`;
            } else if (element.type === 'shape') {
                return `${Math.round(element.width)}×${Math.round(element.height)}`;
            }
            return `Layer ${element.layer}`;
        }

        // Move layer up
        function moveLayerUp(id) {
            const element = elements.find(e => e.id === id);
            if (element) {
                element.layer = Math.max(...elements.map(e => e.layer), 0) + 1;
                updateCanvas();
                updateJSON();
            }
        }

        // Move layer down
        function moveLayerDown(id) {
            const element = elements.find(e => e.id === id);
            if (element) {
                element.layer = Math.max(1, element.layer - 1);
                updateCanvas();
                updateJSON();
            }
        }

        // Delete element from layer
        function deleteElementFromLayer(id) {
            elements = elements.filter(e => e.id !== id);
            if (selectedElement === id) {
                selectedElement = null;
                updateElementProperties();
            }
            updateCanvas();
            updateQuotas();
            updateJSON();
        }

        // Update JSON output
        function updateJSON() {
            try {
                const cardWidth = cardElement.width;
                const cardHeight = cardElement.height;
                const bgType = cardElement.bg_type;
                const bgColor = cardElement.bg;
                const bgImage = cardElement.bg_image;
                const isTransparent = cardElement.bg_transparent;
            
            const payload = {
                card: {
                    width: String(cardWidth),
                    height: String(cardHeight),
                    bg: isTransparent ? '#00000000' : (bgType === 'color' ? bgColor : bgImage),
                    bg_type: bgType
                },
                elements: elements.map(element => {
                    const base = {
                        id: String(element.id),
                        type: element.type,
                        layer: String(element.layer),
                        transparency: String(element.opacity),
                        position: {
                            x: Number(element.x),
                            y: Number(element.y)
                        },
                        size: {
                            width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                            height: Number(element.height)
                        }
                    };
                    
                    if (element.type === 'text') {
                        // Group all text properties together
                        return {
                            id: String(element.id),
                            type: element.type,
                            text: element.text,
                            text_size: String(element.fontSize),
                            font: element.fontFamily,
                            color: element.textColor,
                            transparency: String(element.opacity),
                            layer: String(element.layer),
                            position: {
                                x: Number(element.x),
                                y: Number(element.y)
                            },
                            size: {
                                width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                                height: Number(element.height)
                            }
                        };
                    } else if (element.type === 'image') {
                        base.url = element.imageUrl;
                    } else if (element.type === 'discord_profile') {
                        return {
                            id: String(element.id),
                            type: element.type,
                            user_id: element.userId,
                            transparency: String(element.opacity),
                            layer: String(element.layer),
                            border_radius: String(element.borderRadius || 100),
                            position: {
                                x: Number(element.x),
                                y: Number(element.y)
                            },
                            size: {
                                width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                                height: Number(element.height)
                            }
                        };
                    } else if (element.type === 'roblox_profile') {
                        return {
                            id: String(element.id),
                            type: element.type,
                            user: element.name || 'Username',
                            transparency: String(element.opacity),
                            layer: String(element.layer),
                            border_radius: String(element.borderRadius || 100),
                            position: {
                                x: Number(element.x),
                                y: Number(element.y)
                            },
                            size: {
                                width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                                height: Number(element.height)
                            }
                        };
                    } else if (element.type === 'progressbar') {
                        base.value = Number(element.progressValue);
                        base.max = Number(element.progressMax);
                        base.color = element.progressColor;
                        base.bg_color = element.progressBgColor;
                        base.border_radius = Number(element.progressBorderRadius);
                    } else if (element.type === 'shape') {
                        base.fill = element.shapeFill;
                        base.radius = Number(element.shapeRadius);
                    }
                    
                    return base;
                })
            };
            
                const jsonString = JSON.stringify(payload, null, 2);
                document.getElementById('json-output').value = jsonString;
            } catch (error) {
                // Error updating JSON
            }
        }

        // Fetch Discord avatar
        async function fetchDiscordAvatar(username, element) {
            try {
                // Clean username (remove # and numbers)
                const cleanUsername = username.replace(/#\d{4}$/, '').trim();
                
                if (!cleanUsername) return;
                
                // Show loading state
                element.avatarUrl = '';
                updateCanvas();
                
                // Try to get Discord user ID from username using Discord's public API
                // This is a simplified approach - for production you'd need proper Discord API integration
                
                // For now, we'll use Discord's default avatar system
                // Generate a hash from the username for consistent avatar
                const hash = simpleHash(cleanUsername);
                const avatarIndex = hash % 5; // 5 default Discord avatars
                
                const avatarUrl = `https://cdn.discordapp.com/embed/avatars/${avatarIndex}.png`;
                
                // Update element with fetched avatar
                element.avatarUrl = avatarUrl;
                document.getElementById('prop-avatar-url').value = avatarUrl;
                
                updateCanvas();
                updateJSON();
                
            } catch (error) {
                // Keep current avatar or use default
            }
        }

        // Simple hash function for consistent avatar selection
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }

        // Copy JSON
        function copyJSON() {
            const jsonOutput = document.getElementById('json-output');
            jsonOutput.select();
            document.execCommand('copy');
            
            // Show feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.style.background = 'linear-gradient(135deg, #2ed573 0%, #1e90ff 100%)';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = 'linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%)';
            }, 2000);
        }

        // Show usage guide modal
        function showUsageGuide() {
            const modal = document.getElementById('usage-modal');
            modal.style.display = 'flex';
            document.body.style.overflow = 'hidden'; // Prevent background scrolling
        }

        // Close usage guide modal
        function closeUsageGuide() {
            const modal = document.getElementById('usage-modal');
            modal.style.display = 'none';
            document.body.style.overflow = 'auto'; // Restore scrolling
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('usage-modal');
            if (event.target === modal) {
                closeUsageGuide();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeUsageGuide();
            }
        });

        // Quick Actions Functions
        function centerElement() {
            if (!selectedElement) return;
            
            const element = elements.find(e => e.id === selectedElement);
            if (!element) return;
            
            const canvasWidth = parseInt(document.getElementById('card-width').value);
            const canvasHeight = parseInt(document.getElementById('card-height').value);
            
            // Handle auto width elements (profiles)
            const elementWidth = (element.widthAuto || element.width === 'auto') ? element.height : element.width;
            
            element.x = (canvasWidth - elementWidth) / 2;
            element.y = (canvasHeight - element.height) / 2;
            
            updateCanvas();
            updateElementProperties();
            updateJSON();
        }

        function alignElement(direction) {
            if (!selectedElement) return;
            
            const element = elements.find(e => e.id === selectedElement);
            if (!element) return;
            
            const canvasWidth = parseInt(document.getElementById('card-width').value);
            const canvasHeight = parseInt(document.getElementById('card-height').value);
            
            // Handle auto width elements (profiles)
            const elementWidth = (element.widthAuto || element.width === 'auto') ? element.height : element.width;
            
            switch(direction) {
                case 'top':
                    element.y = 0;
                    break;
                case 'bottom':
                    element.y = canvasHeight - element.height;
                    break;
                case 'left':
                    element.x = 0;
                    break;
                case 'right':
                    element.x = canvasWidth - elementWidth;
                    break;
            }
            
            updateCanvas();
            updateElementProperties();
            updateJSON();
        }

        function fitToCanvas() {
            if (!selectedElement) return;
            
            const element = elements.find(e => e.id === selectedElement);
            if (!element) return;
            
            const canvasWidth = parseInt(document.getElementById('card-width').value);
            const canvasHeight = parseInt(document.getElementById('card-height').value);
            
            // Handle auto width elements (profiles) - they should maintain square aspect ratio
            if (element.widthAuto || element.width === 'auto') {
                const size = Math.min(canvasWidth, canvasHeight);
                element.height = size;
                element.x = (canvasWidth - size) / 2;
                element.y = (canvasHeight - size) / 2;
            } else {
                // Fit element to canvas while maintaining aspect ratio
                const aspectRatio = element.width / element.height;
                const canvasAspectRatio = canvasWidth / canvasHeight;
                
                if (aspectRatio > canvasAspectRatio) {
                    // Element is wider, fit to width
                    element.width = canvasWidth;
                    element.height = canvasWidth / aspectRatio;
                } else {
                    // Element is taller, fit to height
                    element.height = canvasHeight;
                    element.width = canvasHeight * aspectRatio;
                }
                
                // Center the element
                element.x = (canvasWidth - element.width) / 2;
                element.y = (canvasHeight - element.height) / 2;
            }
            
            updateCanvas();
            updateElementProperties();
            updateJSON();
        }

        function resetPosition() {
            if (!selectedElement) return;
            
            const element = elements.find(e => e.id === selectedElement);
            if (!element) return;
            
            // Reset to default position
            element.x = 50;
            element.y = 50;
            
            // Reset to default size based on type
            switch(element.type) {
                case 'text':
                    element.width = 200;
                    element.height = 30;
                    break;
                case 'discord_profile':
                    element.width = 50;
                    element.height = 50;
                    break;
                case 'roblox_profile':
                    element.width = 'auto';
                    element.height = 50;
                    element.widthAuto = true;
                    break;
                case 'image':
                    element.width = 100;
                    element.height = 100;
                    break;
                case 'progressbar':
                    element.width = 200;
                    element.height = 20;
                    break;
                default:
                    element.width = 100;
                    element.height = 100;
            }
            
            updateCanvas();
            updateElementProperties();
            updateJSON();
        }

        // Update quick actions buttons state
        function updateQuickActionsState() {
            const buttons = document.querySelectorAll('.quick-action-btn');
            buttons.forEach(btn => {
                btn.disabled = !selectedElement;
            });
        }

        // Canvas resize functionality
        function initCanvasResize() {
            const canvas = document.getElementById('canvas');
            const resizeHandle = document.getElementById('canvas-resize-handle');
            const widthInput = document.getElementById('card-width');
            const heightInput = document.getElementById('card-height');
            
            let isResizing = false;
            let startX, startY, startWidth, startHeight;

            console.log('Initializing canvas resize...', { 
                canvas: !!canvas, 
                resizeHandle: !!resizeHandle, 
                widthInput: !!widthInput, 
                heightInput: !!heightInput,
                canvasChildren: canvas ? canvas.children.length : 0
            });

            if (!resizeHandle) {
                console.error('Resize handle not found! Creating new one...');
                const newHandle = document.createElement('div');
                newHandle.id = 'canvas-resize-handle';
                newHandle.className = 'canvas-resize-handle';
                canvas.appendChild(newHandle);
                console.log('New resize handle created');
                return initCanvasResize(); // Retry with new handle
            }

            // Make sure handle is visible and clickable
            resizeHandle.style.display = 'block';
            resizeHandle.style.pointerEvents = 'auto';
            resizeHandle.style.opacity = '1';

            resizeHandle.addEventListener('mousedown', function(e) {
                console.log('Resize handle clicked!');
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = cardElement.width;
                startHeight = cardElement.height;
                
                canvas.classList.add('resize-cursor');
                document.body.style.cursor = 'se-resize';
                document.body.style.userSelect = 'none';
                
                e.preventDefault();
                e.stopPropagation();
            });

            const handleMouseMove = function(e) {
                if (!isResizing) return;
                
                console.log('Resizing...', e.clientX, e.clientY);
                
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                const zoom = parseFloat(document.getElementById('canvas-zoom').value);
                
                // Calculate new dimensions
                const newWidth = Math.max(10, Math.min(2000, startWidth + (deltaX / zoom)));
                const newHeight = Math.max(10, Math.min(2000, startHeight + (deltaY / zoom)));
                
                // Update inputs, cardElement, and canvas
                const newWidthRounded = Math.round(newWidth);
                const newHeightRounded = Math.round(newHeight);
                
                widthInput.value = newWidthRounded;
                heightInput.value = newHeightRounded;
                
                // Update cardElement to match inputs
                cardElement.width = newWidthRounded;
                cardElement.height = newHeightRounded;
                
                updateCanvas();
            };

            const handleMouseUp = function() {
                if (isResizing) {
                    console.log('Resize ended');
                    isResizing = false;
                    canvas.classList.remove('resize-cursor');
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    updateJSON();
                }
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Add visual feedback
            resizeHandle.addEventListener('mouseenter', function() {
                this.style.transform = 'scale(1.2)';
                this.style.opacity = '1';
            });

            resizeHandle.addEventListener('mouseleave', function() {
                if (!isResizing) {
                    this.style.transform = 'scale(1)';
                    this.style.opacity = '0.8';
                }
            });

            // Alternative: Allow resize by dragging canvas corner area
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const cornerSize = 20; // 20px corner area
                const isNearCorner = (
                    (e.clientX > rect.right - cornerSize && e.clientY > rect.bottom - cornerSize)
                );

                if (isNearCorner && !e.target.classList.contains('canvas-element')) {
                    console.log('Canvas corner clicked for resize!');
                    isResizing = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startWidth = cardElement.width;
                    startHeight = cardElement.height;
                    
                    canvas.classList.add('resize-cursor');
                    document.body.style.cursor = 'se-resize';
                    document.body.style.userSelect = 'none';
                    
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            // Add scroll zoom functionality
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const zoomSelect = document.getElementById('canvas-zoom');
                const currentZoom = parseFloat(zoomSelect.value);
                const zoomStep = 0.1; // 10% zoom steps
                
                let newZoom;
                if (e.deltaY < 0) {
                    // Scroll up - zoom in
                    newZoom = Math.min(2.0, currentZoom + zoomStep);
                } else {
                    // Scroll down - zoom out
                    newZoom = Math.max(0.25, currentZoom - zoomStep);
                }
                
                // Round to nearest valid zoom level
                const zoomLevels = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0];
                const closestZoom = zoomLevels.reduce((prev, curr) => 
                    Math.abs(curr - newZoom) < Math.abs(prev - newZoom) ? curr : prev
                );
                
                zoomSelect.value = closestZoom;
                console.log('Zoom changed via scroll to:', closestZoom);
                updateCanvas();
                updateJSON();
            });
        }
    </script>
</body>
</html>
