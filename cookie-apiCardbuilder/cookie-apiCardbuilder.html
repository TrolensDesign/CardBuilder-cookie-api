<!--
████████╗██████╗  ██████╗ ██╗     ███████╗███╗   ██╗███████╗
╚══██╔══╝██╔══██╗██╔═══██╗██║     ██╔════╝████╗  ██║██╔════╝
   ██║   ██████╔╝██║   ██║██║     █████╗  ██╔██╗ ██║███████╗
   ██║   ██╔══██╗██║   ██║██║     ██╔══╝  ██║╚██╗██║╚════██║
   ██║   ██║  ██║╚██████╔╝███████╗███████╗██║ ╚████║███████║
   ╚═╝   ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚══════╝╚═╝  ╚═══╝╚══════╝
                                    
                        Designed by Trolens
-->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Trolens Cookie API Card Builder</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Inter:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2d2d44 100%);
            color: #ffffff;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Trolens Brand Header */
        .trolens-header {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(255, 107, 53, 0.3);
            border-bottom: 2px solid #ff6b35;
        }

        .trolens-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .trolens-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .trolens-avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .avatar-fallback {
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            color: #ffffff;
        }

        .trolens-brand {
            font-size: 24px;
            font-weight: 700;
            color: #ffffff;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .trolens-tagline {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: -4px;
        }

        .version-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            color: #ffffff;
        }

        .container {
            display: grid;
            grid-template-columns: 240px 1fr 280px;
            height: calc(100vh - 64px);
            gap: 1px;
            background: #3a3a3a;
        }

        /* Left Panel - Elements */
        .left-panel {
            background: #2a2a3a;
            padding: 12px;
            overflow-y: auto;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #ff6b35;
        }

        .element-group {
            margin-bottom: 16px;
        }

        .element-group h3 {
            font-size: 11px;
            color: #a0a0a0;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .element-btn {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 4px;
            background: linear-gradient(135deg, #4a4a5a 0%, #3a3a4a 100%);
            border: 1px solid #5a5a6a;
            border-radius: 6px;
            color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .element-btn:hover {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            border-color: #ff6b35;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .element-btn:active {
            transform: translateY(0);
        }

        .element-icon {
            width: 16px;
            height: 16px;
            background: #ff6b35;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .quota {
            font-size: 10px;
            color: #888;
            margin-left: auto;
        }

        /* Center Panel - Canvas */
        .center-panel {
            background: #1a1a2a;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .canvas-header {
            padding: 12px 16px;
            background: #2a2a3a;
            border-bottom: 1px solid #3a3a4a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canvas-title {
            font-size: 14px;
            font-weight: 600;
        }

        .canvas-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .control-group label {
            font-size: 11px;
            color: #a0a0a0;
        }

        .control-group input, .control-group select {
            padding: 4px 8px;
            background: #3a3a4a;
            border: 1px solid #5a5a6a;
            border-radius: 4px;
            color: #ffffff;
            font-size: 11px;
            width: 60px;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
        }

        .canvas {
            background: #ffffff;
            border: 2px solid #ff6b35;
            border-radius: 0px;
            position: relative;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .canvas.transparent {
            background: transparent;
            background-image: 
                linear-gradient(45deg, rgba(200, 200, 200, 0.15) 25%, transparent 25%), 
                linear-gradient(-45deg, rgba(200, 200, 200, 0.15) 25%, transparent 25%), 
                linear-gradient(45deg, transparent 75%, rgba(200, 200, 200, 0.15) 75%), 
                linear-gradient(-45deg, transparent 75%, rgba(200, 200, 200, 0.15) 75%);
            background-size: 16px 16px;
            background-position: 0 0, 0 8px, 8px -8px, -8px 0px;
        }

        .canvas-element {
            position: absolute;
            cursor: move;
            border: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .canvas-element:hover {
            border-color: #ff6b35;
        }

        .canvas-element.selected {
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.3);
        }

        .canvas-element .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #ff6b35;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .canvas-element.selected .resize-handle {
            opacity: 1;
        }

        .resize-handle.nw { top: -4px; left: -4px; cursor: nw-resize; }
        .resize-handle.ne { top: -4px; right: -4px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -4px; left: -4px; cursor: sw-resize; }
        .resize-handle.se { bottom: -4px; right: -4px; cursor: se-resize; }

        /* Right Panel - Properties */
        .right-panel {
            background: #2a2a3a;
            padding: 12px;
            overflow-y: auto;
        }

        .property-group {
            margin-bottom: 12px;
        }

        .property-group h3 {
            font-size: 11px;
            color: #a0a0a0;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .property-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 6px;
        }

        .property-row.single {
            grid-template-columns: 1fr;
        }

        .property-row label {
            font-size: 10px;
            color: #ffffff;
            margin-bottom: 2px;
            display: block;
        }

        .property-row input, .property-row select, .property-row textarea {
            width: 100%;
            padding: 6px 8px;
            background: #3a3a4a;
            border: 1px solid #5a5a6a;
            border-radius: 4px;
            color: #ffffff;
            font-size: 11px;
        }

        .property-row input:focus, .property-row select:focus, .property-row textarea:focus {
            outline: none;
            border-color: #ff6b35;
            box-shadow: 0 0 0 2px rgba(255, 107, 53, 0.2);
        }

        .json-output {
            background: #1a1a2a;
            border: 1px solid #3a3a4a;
            border-radius: 6px;
            padding: 8px;
            margin-top: 12px;
        }

        .json-output h3 {
            font-size: 11px;
            color: #ff6b35;
            margin-bottom: 6px;
        }

        .json-textarea {
            width: 100%;
            height: 120px;
            background: #0a0a1a;
            border: 1px solid #3a3a4a;
            border-radius: 4px;
            color: #ffffff;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            padding: 6px;
            resize: vertical;
        }

        .copy-btn {
            width: 100%;
            padding: 6px;
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            border: none;
            border-radius: 4px;
            color: #ffffff;
            font-weight: 600;
            cursor: pointer;
            margin-top: 6px;
            transition: all 0.3s ease;
            font-size: 11px;
        }

        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
        }

        .no-selection {
            text-align: center;
            color: #666;
            font-style: italic;
            margin-top: 50px;
        }

        /* Layers Panel */
        .layers-list {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid #3a3a4a;
            border-radius: 4px;
            background: #1a1a2a;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-bottom: 1px solid #2a2a3a;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .layer-item:hover {
            background: #3a3a4a;
        }

        .layer-item.selected {
            background: #ff6b35;
            color: #ffffff;
        }

        .layer-item:last-child {
            border-bottom: none;
        }

        .layer-icon {
            width: 16px;
            height: 16px;
            background: #ff6b35;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            margin-right: 6px;
            flex-shrink: 0;
        }

        .layer-info {
            flex: 1;
            min-width: 0;
        }

        .layer-name {
            font-size: 11px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-details {
            font-size: 9px;
            color: #a0a0a0;
            margin-top: 1px;
        }

        .layer-controls {
            display: flex;
            gap: 4px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .layer-item:hover .layer-controls {
            opacity: 1;
        }

        .layer-btn {
            width: 16px;
            height: 16px;
            background: #4a4a5a;
            border: none;
            border-radius: 2px;
            color: #ffffff;
            cursor: pointer;
            font-size: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .layer-btn:hover {
            background: #ff6b35;
        }

        .layer-btn.delete:hover {
            background: #ff4757;
        }

        .no-layers {
            padding: 12px;
            text-align: center;
            color: #666;
            font-style: italic;
            font-size: 10px;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 200px 1fr 240px;
            }
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto;
            }
            
            .left-panel, .right-panel {
                max-height: 150px;
            }
            
            .trolens-header {
                padding: 8px 16px;
            }
            
            .trolens-brand {
                font-size: 20px;
            }
            
            .trolens-avatar {
                width: 32px;
                height: 32px;
            }
            
            .avatar-fallback {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Trolens Brand Header -->
    <div class="trolens-header">
        <div class="trolens-logo">
            <div class="trolens-avatar">
                <img src="https://cdn.discordapp.com/avatars/1011787830567120898/51b35a89cc0046bd8720770163fe680f.png" 
                     alt="Trolens Avatar" 
                     onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';">
                <div class="avatar-fallback">T</div>
            </div>
            <div>
                <div class="trolens-brand">Designed By Trolens</div>
                <div class="trolens-tagline">Cookie API Card Builder</div>
            </div>
        </div>
        <div class="version-badge">v2.0</div>
    </div>
    
    <div class="container">
        <!-- Left Panel - Elements -->
        <div class="left-panel">
            <div class="panel-title">Elements</div>
            
            <div class="element-group">
                <h3>Basic Elements</h3>
                <button class="element-btn" onclick="addElement('text')">
                    <div class="element-icon">T</div>
                    Text
                    <span class="quota" id="quota-text">0/100</span>
                </button>
                <button class="element-btn" onclick="addElement('image')">
                    <div class="element-icon">🖼</div>
                    Image
                    <span class="quota" id="quota-image">0/10</span>
                </button>
            </div>

            <div class="element-group">
                <h3>Profiles</h3>
                <button class="element-btn" onclick="addElement('discord_profile')">
                    <div class="element-icon">💬</div>
                    Discord Profile
                    <span class="quota" id="quota-discord">0/10</span>
                </button>
                <button class="element-btn" onclick="addElement('roblox_profile')">
                    <div class="element-icon">🎮</div>
                    Roblox Profile
                    <span class="quota" id="quota-roblox">0/10</span>
                </button>
            </div>

            <div class="element-group">
                <h3>Advanced</h3>
                <button class="element-btn" onclick="addElement('progressbar')">
                    <div class="element-icon">📊</div>
                    Progress Bar
                    <span class="quota" id="quota-progressbar">0/1</span>
                </button>
            </div>
        </div>

        <!-- Center Panel - Canvas -->
        <div class="center-panel">
            <div class="canvas-header">
                <div class="canvas-title">Card Canvas</div>
                <div class="canvas-controls">
                    <div class="control-group">
                        <label>Width:</label>
                        <input type="number" id="card-width" value="800" min="100" max="2000">
                    </div>
                    <div class="control-group">
                        <label>Height:</label>
                        <input type="number" id="card-height" value="400" min="100" max="2000">
                    </div>
                    <div class="control-group">
                        <label>Zoom:</label>
                        <select id="canvas-zoom">
                            <option value="0.5">50%</option>
                            <option value="0.75">75%</option>
                            <option value="1" selected>100%</option>
                            <option value="1.25">125%</option>
                            <option value="1.5">150%</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="canvas-container">
                <div class="canvas" id="canvas"></div>
            </div>
        </div>

        <!-- Right Panel - Properties -->
        <div class="right-panel">
            <div class="panel-title">Properties</div>
            
            <div id="card-properties">
                <div class="property-group">
                    <h3>Card Settings</h3>
                    <div class="property-row single">
                        <div>
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" id="bg-transparent" style="width: auto; margin: 0;">
                                <span>Transparent Background</span>
                            </label>
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Background Type</label>
                            <select id="bg-type">
                                <option value="color">Color</option>
                                <option value="image">Image URL</option>
                            </select>
                        </div>
                        <div id="color-picker-container">
                            <label>Background</label>
                            <input type="color" id="bg-color" value="#1a1a2a">
                        </div>
                    </div>
                    <div class="property-row single">
                        <div id="image-url-container">
                            <label>Background Image URL</label>
                            <input type="url" id="bg-image" placeholder="https://example.com/image.png">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Layers Panel -->
            <div class="property-group">
                <h3>Layers</h3>
                <div id="layers-list" class="layers-list">
                    <div class="no-layers">No elements added yet</div>
                </div>
            </div>

            <div id="element-properties" style="display: none;">
                <div class="property-group">
                    <h3>Element Properties</h3>
                    <div class="property-row">
                        <div>
                            <label>X Position</label>
                            <input type="number" id="prop-x" step="0.1">
                        </div>
                        <div>
                            <label>Y Position</label>
                            <input type="number" id="prop-y" step="0.1">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Width</label>
                            <div style="display: flex; gap: 4px; align-items: center;">
                                <input type="checkbox" id="prop-width-auto" style="width: auto;">
                                <label for="prop-width-auto" style="font-size: 10px; margin: 0;">Auto</label>
                                <input type="number" id="prop-width" step="0.1" style="flex: 1;">
                            </div>
                        </div>
                        <div>
                            <label>Height</label>
                            <input type="number" id="prop-height" step="0.1">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Opacity</label>
                            <input type="range" id="prop-opacity" min="0" max="100" value="100">
                        </div>
                        <div>
                            <label>Layer</label>
                            <input type="number" id="prop-layer" value="1">
                        </div>
                    </div>
                </div>

                <div id="text-properties" class="property-group" style="display: none;">
                    <h3>Text Properties</h3>
                    <div class="property-row single">
                        <div>
                            <label>Text Content</label>
                            <textarea id="prop-text" rows="3"></textarea>
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Font Size</label>
                            <input type="number" id="prop-font-size" value="16">
                        </div>
                        <div>
                            <label>Font Family</label>
                            <input type="text" id="prop-font-family" value="DM Sans" placeholder="DM Sans, Roboto, Open Sans, etc.">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Text Color</label>
                            <input type="color" id="prop-text-color" value="#ffffff">
                        </div>
                        <div>
                            <label>Text Align</label>
                            <select id="prop-text-align">
                                <option value="left">Left</option>
                                <option value="center">Center</option>
                                <option value="right">Right</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div id="image-properties" class="property-group" style="display: none;">
                    <h3>Image Properties</h3>
                    <div class="property-row single">
                        <div>
                            <label>Image URL</label>
                            <input type="url" id="prop-image-url" placeholder="https://example.com/image.png">
                        </div>
                    </div>
                </div>

                <div id="profile-properties" class="property-group" style="display: none;">
                    <h3>Profile Properties</h3>
                    <div class="property-row">
                        <div>
                            <label>Username</label>
                            <input type="text" id="prop-name" placeholder="redxxxkiller">
                        </div>
                        <div>
                            <label>Border Radius</label>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <input type="range" id="prop-subtitle-slider" min="0" max="100" value="100" style="flex: 1;">
                                <input type="number" id="prop-subtitle" placeholder="100" min="0" max="100" style="width: 60px;">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="progress-properties" class="property-group" style="display: none;">
                    <h3>Progress Properties</h3>
                    <div class="property-row">
                        <div>
                            <label>Value</label>
                            <input type="number" id="prop-progress-value" min="0" value="60">
                        </div>
                        <div>
                            <label>Max Value</label>
                            <input type="number" id="prop-progress-max" min="1" value="100">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Bar Color</label>
                            <input type="color" id="prop-progress-color" value="#ff6b35">
                        </div>
                        <div>
                            <label>Background Color</label>
                            <input type="color" id="prop-progress-bg-color" value="#333333">
                        </div>
                    </div>
                    <div class="property-row">
                        <div>
                            <label>Border Radius</label>
                            <input type="number" id="prop-progress-border-radius" min="0" value="0">
                        </div>
                        <div></div>
                    </div>
                </div>


                <div class="property-group">
                    <button class="copy-btn" onclick="deleteElement()" style="background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%);">
                        Delete Element
                    </button>
                </div>
            </div>

            <div class="json-output">
                <h3>JSON Output</h3>
                <textarea class="json-textarea" id="json-output" readonly></textarea>
                <button class="copy-btn" onclick="copyJSON()">Copy JSON</button>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let elements = [];
        let selectedElement = null;
        let elementIdCounter = 1;

        // Limits
        const LIMITS = {
            text: 100,
            image: 10,
            discord_profile: 10,
            roblox_profile: 10,
            progressbar: 1,
            shape: 50
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateCanvas();
            updateQuotas();
            updateJSON();
            
            // Card property listeners
            document.getElementById('card-width').addEventListener('input', updateCanvas);
            document.getElementById('card-height').addEventListener('input', updateCanvas);
            document.getElementById('bg-type').addEventListener('change', handleBackgroundTypeChange);
            document.getElementById('bg-color').addEventListener('input', updateCanvas);
            document.getElementById('bg-image').addEventListener('input', updateCanvas);
            document.getElementById('bg-transparent').addEventListener('change', handleTransparencyToggle);
        });

        // Add element
        function addElement(type) {
            // Check if type is supported
            if (!LIMITS.hasOwnProperty(type)) {
                console.warn(`Element type '${type}' is not supported`);
                return;
            }
            
            if (elements.filter(e => e.type === type).length >= LIMITS[type]) {
                alert(`Limit reached for ${type} elements (${LIMITS[type]})`);
                return;
            }

            const element = {
                id: elementIdCounter++,
                type: type,
                x: 50,
                y: 50,
                width: type === 'text' ? 200 : (type === 'discord_profile' ? 50 : 100),
                height: type === 'text' ? 30 : (type === 'discord_profile' ? 50 : 100),
                widthAuto: type === 'discord_profile' ? true : false,
                opacity: 100,
                layer: elements.length + 1,
                text: type === 'text' ? 'Sample Text' : '',
                fontSize: 16,
                fontFamily: 'DM Sans',
                textColor: '#ffffff',
                textAlign: 'left',
                imageUrl: '',
                avatarUrl: '',
                name: '',
                subtitle: 'Status',
                userId: type === 'discord_profile' ? '1011787830567120898' : undefined,
                borderRadius: type === 'discord_profile' ? 100 : undefined,
                progressValue: 60,
                progressMax: 100,
                progressColor: '#ff6b35',
                progressBgColor: '#333333',
                progressBorderRadius: 0,
                shapeFill: '#ff6b35',
                shapeRadius: 8
            };

            elements.push(element);
            updateCanvas();
            updateQuotas();
            updateJSON();
            selectElement(element.id);
        }

        // Handle background type change
        function handleBackgroundTypeChange() {
            const bgType = document.getElementById('bg-type').value;
            const colorPickerContainer = document.getElementById('color-picker-container');
            const imageUrlContainer = document.getElementById('image-url-container');
            
            if (bgType === 'image') {
                // Hide color picker, show image URL
                colorPickerContainer.style.display = 'none';
                imageUrlContainer.style.display = 'block';
            } else {
                // Show color picker, hide image URL
                colorPickerContainer.style.display = 'block';
                imageUrlContainer.style.display = 'none';
            }
            
            // Update canvas and JSON
            updateCanvas();
            updateJSON();
        }

        // Handle transparency toggle
        function handleTransparencyToggle() {
            const isTransparent = document.getElementById('bg-transparent').checked;
            const bgTypeSelect = document.getElementById('bg-type');
            const bgColorInput = document.getElementById('bg-color');
            const bgImageInput = document.getElementById('bg-image');
            const colorPickerContainer = document.getElementById('color-picker-container');
            const imageUrlContainer = document.getElementById('image-url-container');
            
            if (isTransparent) {
                // Hide all background controls when transparent
                bgTypeSelect.disabled = true;
                bgColorInput.disabled = true;
                bgImageInput.disabled = true;
                colorPickerContainer.style.display = 'none';
                imageUrlContainer.style.display = 'none';
            } else {
                // Re-enable background type selector
                bgTypeSelect.disabled = false;
                // Handle background type visibility
                handleBackgroundTypeChange();
            }
            
            // Update canvas and JSON
            updateCanvas();
            updateJSON();
        }

        // Update canvas
        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const width = parseInt(document.getElementById('card-width').value);
            const height = parseInt(document.getElementById('card-height').value);
            const zoom = parseFloat(document.getElementById('canvas-zoom').value);
            
            canvas.style.width = (width * zoom) + 'px';
            canvas.style.height = (height * zoom) + 'px';
            
            // Handle transparency
            const isTransparent = document.getElementById('bg-transparent').checked;
            
            if (isTransparent) {
                canvas.classList.add('transparent');
                // Remove any inline background styles to let CSS handle the pattern
                canvas.style.background = '';
                canvas.style.backgroundImage = '';
            } else {
                canvas.classList.remove('transparent');
                // Set background
                const bgType = document.getElementById('bg-type').value;
                if (bgType === 'color') {
                    canvas.style.background = document.getElementById('bg-color').value;
                } else {
                    const bgImage = document.getElementById('bg-image').value;
                    canvas.style.background = bgImage ? `url(${bgImage}) center/cover` : '#1a1a2a';
                }
            }
            
            // Clear canvas
            canvas.innerHTML = '';
            
            // Render elements
            const sortedElements = [...elements].sort((a, b) => a.layer - b.layer);
            sortedElements.forEach(element => {
                const elementDiv = createElementDiv(element, zoom);
                canvas.appendChild(elementDiv);
            });
            
            // Update layers panel
            updateLayersPanel();
        }

        // Create element div
        function createElementDiv(element, zoom) {
            const div = document.createElement('div');
            div.className = 'canvas-element';
            div.dataset.id = element.id;
            
            if (selectedElement === element.id) {
                div.classList.add('selected');
            }
            
            div.style.left = (element.x * zoom) + 'px';
            div.style.top = (element.y * zoom) + 'px';
            
            // Handle auto width
            if (element.widthAuto || element.width === 'auto') {
                div.style.width = (element.height * zoom) + 'px'; // Make width equal to height for square elements
            } else {
                div.style.width = (element.width * zoom) + 'px';
            }
            div.style.height = (element.height * zoom) + 'px';
            div.style.opacity = element.opacity / 100;
            
            // Create content based on type
            let content = '';
            try {
                if (element.type === 'text') {
                content = `<div style="
                    font-family: ${element.fontFamily};
                    font-size: ${element.fontSize * zoom}px;
                    color: ${element.textColor};
                    text-align: ${element.textAlign};
                    padding: 4px;
                    white-space: pre-wrap;
                ">${element.text}</div>`;
            } else if (element.type === 'image') {
                if (element.imageUrl && element.imageUrl.trim() !== '') {
                    content = `<img src="${element.imageUrl}" style="width: 100%; height: 100%; object-fit: cover;" onerror="if(this) this.style.display='none'">`;
                } else {
                    content = `<div style="
                        width: 100%;
                        height: 100%;
                        background: #f0f0f0;
                        border: 2px dashed #ccc;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: #666;
                        font-size: 12px;
                        text-align: center;
                        padding: 8px;
                        box-sizing: border-box;
                    ">
                        <div style="font-size: 24px; margin-bottom: 8px;">🖼️</div>
                        <div>Please fill the URL</div>
                    </div>`;
                }
            } else if (element.type === 'discord_profile') {
                const borderRadius = element.borderRadius || 100;
                const userId = element.userId;
                
                if (userId && userId.trim() !== '') {
                    // Check if it's your User ID
                    const isYourId = userId === '1011787830567120898';
                    
                    let avatarUrl;
                    if (isYourId) {
                        // Your actual avatar
                        avatarUrl = `https://cdn.discordapp.com/avatars/1011787830567120898/51b35a89cc0046bd8720770163fe680f.png`;
                    } else {
                        // Default avatar for other users
                        const defaultIndex = parseInt(userId) % 5;
                        avatarUrl = `https://cdn.discordapp.com/embed/avatars/${defaultIndex}.png`;
                    }
                    
                    content = `<img src="${avatarUrl}" 
                        style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: ${borderRadius}%;
                        " 
                        onerror="this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex';"
                    >
                    <div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: #5865f2;
                        display: none;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 14px;
                    ">D</div>`;
                } else {
                    content = `<div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: #5865f2;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 14px;
                    ">D</div>`;
                }
            } else if (element.type === 'roblox_profile') {
                const borderRadius = element.borderRadius || 100;
                const username = element.name;
                
                if (username && username.trim() !== '') {
                    // Use Roblox avatar API - this requires user ID, not username
                    // For now, we'll use a placeholder that shows the username was entered
                    const avatarUrl = `https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=${username}&size=150x150&format=Png`;
                    content = `<img src="${avatarUrl}" 
                        style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: ${borderRadius}%;
                        " 
                        onerror="this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex';"
                    >
                    <div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: linear-gradient(135deg, #00a2ff 0%, #00d4ff 100%);
                        display: none;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                    ">R</div>`;
                } else {
                    // Default Roblox app icon
                    content = `<img src="https://static.wikia.nocookie.net/logopedia/images/d/d6/Roblox_app_icon_2022.svg/revision/latest/scale-to-width-down/250?cb=20220319140506" 
                        style="
                            width: 100%;
                            height: 100%;
                            object-fit: cover;
                            border-radius: ${borderRadius}%;
                        " 
                        onerror="this.style.display='none'; if(this.nextElementSibling) this.nextElementSibling.style.display='flex';"
                    >
                    <div style="
                        width: 100%;
                        height: 100%;
                        border-radius: ${borderRadius}%;
                        background: linear-gradient(135deg, #00a2ff 0%, #00d4ff 100%);
                        display: none;
                        align-items: center;
                        justify-content: center;
                        color: white;
                        font-weight: bold;
                        font-size: 12px;
                    ">R</div>`;
                }
            } else if (element.type === 'progressbar') {
                const progressPercent = (element.progressValue / element.progressMax) * 100;
                content = `<div style="
                    width: 100%;
                    height: 100%;
                    background: ${element.progressBgColor};
                    border-radius: ${element.progressBorderRadius}px;
                    overflow: hidden;
                ">
                    <div style="
                        width: ${progressPercent}%;
                        height: 100%;
                        background: ${element.progressColor};
                        transition: width 0.3s ease;
                    "></div>
                </div>`;
            } else if (element.type === 'shape') {
                content = `<div style="
                    width: 100%;
                    height: 100%;
                    background: ${element.shapeFill};
                    border-radius: ${element.shapeRadius}px;
                "></div>`;
            }
            } catch (error) {
                console.error('Error rendering element:', error);
                content = `<div style="
                    width: 100%;
                    height: 100%;
                    background: #ff4757;
                    color: white;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                ">Error</div>`;
            }
            
            div.innerHTML = content;
            
            // Add resize handles
            if (selectedElement === element.id) {
                div.innerHTML += `
                    <div class="resize-handle nw"></div>
                    <div class="resize-handle ne"></div>
                    <div class="resize-handle sw"></div>
                    <div class="resize-handle se"></div>
                `;
            }
            
            // Add event listeners
            div.addEventListener('click', (e) => {
                e.stopPropagation();
                selectElement(element.id);
            });
            
            div.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) {
                    e.stopPropagation();
                    startResize(element.id, e.target.className.split(' ')[1]);
                } else {
                    e.stopPropagation();
                    startDrag(element.id, e);
                }
            });
            
            return div;
        }

        // Select element
        function selectElement(id) {
            selectedElement = id;
            updateCanvas();
            updateElementProperties();
        }

        // Update element properties panel
        function updateElementProperties() {
            const element = elements.find(e => e.id === selectedElement);
            if (!element) {
                document.getElementById('element-properties').style.display = 'none';
                document.getElementById('card-properties').style.display = 'block';
                return;
            }
            
            document.getElementById('element-properties').style.display = 'block';
            document.getElementById('card-properties').style.display = 'none';
            
            // Update property fields with current values
            document.getElementById('prop-x').value = element.x;
            document.getElementById('prop-y').value = element.y;
            document.getElementById('prop-width').value = element.width;
            document.getElementById('prop-height').value = element.height;
            document.getElementById('prop-opacity').value = element.opacity;
            document.getElementById('prop-layer').value = element.layer;
            
            // Update auto width checkbox
            const isAutoWidth = element.widthAuto || element.width === 'auto';
            document.getElementById('prop-width-auto').checked = isAutoWidth;
            document.getElementById('prop-width').disabled = isAutoWidth;
            
            // If auto width, show the height value in width field for reference
            if (isAutoWidth) {
                document.getElementById('prop-width').value = element.height;
            }
            
            // Show/hide type-specific properties
            const textProps = document.getElementById('text-properties');
            const imageProps = document.getElementById('image-properties');
            const profileProps = document.getElementById('profile-properties');
            const progressProps = document.getElementById('progress-properties');
            const shapeProps = document.getElementById('shape-properties');
            
            if (textProps) textProps.style.display = element.type === 'text' ? 'block' : 'none';
            if (imageProps) imageProps.style.display = element.type === 'image' ? 'block' : 'none';
            if (profileProps) profileProps.style.display = (element.type === 'discord_profile' || element.type === 'roblox_profile') ? 'block' : 'none';
            if (progressProps) progressProps.style.display = element.type === 'progressbar' ? 'block' : 'none';
            if (shapeProps) shapeProps.style.display = element.type === 'shape' ? 'block' : 'none';
            
            // Hide position and height fields for Discord profiles
            const positionFields = document.querySelectorAll('#prop-x, #prop-y, #prop-height');
            positionFields.forEach(field => {
                if (field) {
                    const row = field.closest('.property-row');
                    if (row) {
                        row.style.display = element.type === 'discord_profile' ? 'none' : 'flex';
                    }
                }
            });
            
            // Update type-specific fields
            if (element.type === 'text') {
                const propText = document.getElementById('prop-text');
                const propFontSize = document.getElementById('prop-font-size');
                const propFontFamily = document.getElementById('prop-font-family');
                const propTextColor = document.getElementById('prop-text-color');
                const propTextAlign = document.getElementById('prop-text-align');
                
                if (propText) propText.value = element.text;
                if (propFontSize) propFontSize.value = element.fontSize;
                if (propFontFamily) propFontFamily.value = element.fontFamily;
                if (propTextColor) propTextColor.value = element.textColor;
                if (propTextAlign) propTextAlign.value = element.textAlign;
            } else if (element.type === 'image') {
                const propImageUrl = document.getElementById('prop-image-url');
                if (propImageUrl) propImageUrl.value = element.imageUrl;
            } else if (element.type === 'discord_profile') {
                const propName = document.getElementById('prop-name');
                const propSubtitle = document.getElementById('prop-subtitle');
                const propSubtitleSlider = document.getElementById('prop-subtitle-slider');
                
                if (propName) propName.value = element.userId || '';
                if (propSubtitle) propSubtitle.value = element.borderRadius || 100;
                if (propSubtitleSlider) propSubtitleSlider.value = element.borderRadius || 100;
            } else if (element.type === 'roblox_profile') {
                const propName = document.getElementById('prop-name');
                const propSubtitle = document.getElementById('prop-subtitle');
                const propSubtitleSlider = document.getElementById('prop-subtitle-slider');
                
                if (propName) propName.value = element.name || '';
                if (propSubtitle) propSubtitle.value = element.borderRadius || 100;
                if (propSubtitleSlider) propSubtitleSlider.value = element.borderRadius || 100;
            } else if (element.type === 'progressbar') {
                const propProgressValue = document.getElementById('prop-progress-value');
                const propProgressMax = document.getElementById('prop-progress-max');
                const propProgressColor = document.getElementById('prop-progress-color');
                const propProgressBgColor = document.getElementById('prop-progress-bg-color');
                const propProgressBorderRadius = document.getElementById('prop-progress-border-radius');
                
                if (propProgressValue) propProgressValue.value = element.progressValue;
                if (propProgressMax) propProgressMax.value = element.progressMax;
                if (propProgressColor) propProgressColor.value = element.progressColor;
                if (propProgressBgColor) propProgressBgColor.value = element.progressBgColor;
                if (propProgressBorderRadius) propProgressBorderRadius.value = element.progressBorderRadius;
            } else if (element.type === 'shape') {
                const propShapeFill = document.getElementById('prop-shape-fill');
                const propShapeRadius = document.getElementById('prop-shape-radius');
                
                if (propShapeFill) propShapeFill.value = element.shapeFill;
                if (propShapeRadius) propShapeRadius.value = element.shapeRadius;
            }
            
            // Add property change listeners
            addPropertyListeners();
        }

        // Add property change listeners
        function addPropertyListeners() {
            const element = elements.find(e => e.id === selectedElement);
            if (!element) return;
            
            // Basic properties
            document.getElementById('prop-x').oninput = () => {
                element.x = parseFloat(document.getElementById('prop-x').value);
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-y').oninput = () => {
                element.y = parseFloat(document.getElementById('prop-y').value);
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-width').oninput = () => {
                if (!document.getElementById('prop-width-auto').checked) {
                    element.width = parseFloat(document.getElementById('prop-width').value);
                    updateCanvas();
                    updateJSON();
                }
            };
            document.getElementById('prop-width-auto').onchange = () => {
                const isAuto = document.getElementById('prop-width-auto').checked;
                element.widthAuto = isAuto;
                document.getElementById('prop-width').disabled = isAuto;
                if (isAuto) {
                    element.width = 'auto';
                    // Show height value in width field for reference
                    document.getElementById('prop-width').value = element.height;
                } else {
                    element.width = parseFloat(document.getElementById('prop-width').value);
                }
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-height').oninput = () => {
                element.height = parseFloat(document.getElementById('prop-height').value);
                // If auto width is enabled, update the width field to show the new height
                if (element.widthAuto || element.width === 'auto') {
                    document.getElementById('prop-width').value = element.height;
                }
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-opacity').oninput = () => {
                element.opacity = parseInt(document.getElementById('prop-opacity').value);
                updateCanvas();
                updateJSON();
            };
            document.getElementById('prop-layer').oninput = () => {
                element.layer = parseInt(document.getElementById('prop-layer').value);
                updateCanvas();
                updateJSON();
            };
            
            // Text properties
            if (element.type === 'text') {
                document.getElementById('prop-text').oninput = () => {
                    element.text = document.getElementById('prop-text').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-font-size').oninput = () => {
                    element.fontSize = parseInt(document.getElementById('prop-font-size').value);
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-font-family').oninput = () => {
                    element.fontFamily = document.getElementById('prop-font-family').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-text-color').oninput = () => {
                    element.textColor = document.getElementById('prop-text-color').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-text-align').onchange = () => {
                    element.textAlign = document.getElementById('prop-text-align').value;
                    updateCanvas();
                    updateJSON();
                };
            }
            
            // Image properties
            if (element.type === 'image') {
                document.getElementById('prop-image-url').oninput = () => {
                    element.imageUrl = document.getElementById('prop-image-url').value;
                    updateCanvas();
                    updateJSON();
                    // Update property values to reflect current position
                    updateElementProperties();
                };
            }
            
            // Profile properties
            if (element.type === 'discord_profile') {
                // Set width to auto for Discord profiles
                element.widthAuto = true;
                
                document.getElementById('prop-name').oninput = () => {
                    const userId = document.getElementById('prop-name').value;
                    element.userId = userId;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle').oninput = () => {
                    const value = parseInt(document.getElementById('prop-subtitle').value) || 100;
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle-slider').value = value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle-slider').oninput = () => {
                    const value = parseInt(document.getElementById('prop-subtitle-slider').value);
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle').value = value;
                    updateCanvas();
                    updateJSON();
                };
            } else if (element.type === 'roblox_profile') {
                document.getElementById('prop-name').oninput = () => {
                    const username = document.getElementById('prop-name').value;
                    element.name = username;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle').oninput = () => {
                    const value = parseInt(document.getElementById('prop-subtitle').value) || 100;
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle-slider').value = value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-subtitle-slider').oninput = () => {
                    const value = parseInt(document.getElementById('prop-subtitle-slider').value);
                    element.borderRadius = value;
                    document.getElementById('prop-subtitle').value = value;
                    updateCanvas();
                    updateJSON();
                };
            }
            
            // Progress properties
            if (element.type === 'progressbar') {
                document.getElementById('prop-progress-value').oninput = () => {
                    element.progressValue = parseInt(document.getElementById('prop-progress-value').value);
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-max').oninput = () => {
                    element.progressMax = parseInt(document.getElementById('prop-progress-max').value);
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-color').oninput = () => {
                    element.progressColor = document.getElementById('prop-progress-color').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-bg-color').oninput = () => {
                    element.progressBgColor = document.getElementById('prop-progress-bg-color').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-progress-border-radius').oninput = () => {
                    element.progressBorderRadius = parseInt(document.getElementById('prop-progress-border-radius').value);
                    updateCanvas();
                    updateJSON();
                };
            }
            
            // Shape properties
            if (element.type === 'shape') {
                document.getElementById('prop-shape-fill').oninput = () => {
                    element.shapeFill = document.getElementById('prop-shape-fill').value;
                    updateCanvas();
                    updateJSON();
                };
                document.getElementById('prop-shape-radius').oninput = () => {
                    element.shapeRadius = parseInt(document.getElementById('prop-shape-radius').value);
                    updateCanvas();
                    updateJSON();
                };
            }
        }

        // Start drag
        function startDrag(id, e) {
            const element = elements.find(el => el.id === id);
            const startX = e.clientX;
            const startY = e.clientY;
            const startElementX = element.x;
            const startElementY = element.y;
            const zoom = parseFloat(document.getElementById('canvas-zoom').value);
            
            function onMouseMove(e) {
                const deltaX = (e.clientX - startX) / zoom;
                const deltaY = (e.clientY - startY) / zoom;
                element.x = startElementX + deltaX;
                element.y = startElementY + deltaY;
                updateCanvas();
                updateElementProperties();
                updateJSON();
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // Start resize
        function startResize(id, direction) {
            const element = elements.find(el => el.id === id);
            const startX = event.clientX;
            const startY = event.clientY;
            const startElementX = element.x;
            const startElementY = element.y;
            const startWidth = element.width;
            const startHeight = element.height;
            const zoom = parseFloat(document.getElementById('canvas-zoom').value);
            
            function onMouseMove(e) {
                const deltaX = (e.clientX - startX) / zoom;
                const deltaY = (e.clientY - startY) / zoom;
                
                if (direction.includes('e')) {
                    element.width = Math.max(10, startWidth + deltaX);
                }
                if (direction.includes('w')) {
                    element.width = Math.max(10, startWidth - deltaX);
                    element.x = startElementX + deltaX;
                }
                if (direction.includes('s')) {
                    element.height = Math.max(10, startHeight + deltaY);
                }
                if (direction.includes('n')) {
                    element.height = Math.max(10, startHeight - deltaY);
                    element.y = startElementY + deltaY;
                }
                
                updateCanvas();
                updateElementProperties();
                updateJSON();
            }
            
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // Delete element
        function deleteElement() {
            if (selectedElement) {
                elements = elements.filter(e => e.id !== selectedElement);
                selectedElement = null;
                updateCanvas();
                updateQuotas();
                updateJSON();
                updateElementProperties();
            }
        }

        // Update quotas
        function updateQuotas() {
        const counts = {
            text: elements.filter(e => e.type === 'text').length,
            image: elements.filter(e => e.type === 'image').length,
            discord_profile: elements.filter(e => e.type === 'discord_profile').length,
            roblox_profile: elements.filter(e => e.type === 'roblox_profile').length,
            progressbar: elements.filter(e => e.type === 'progressbar').length,
            shape: elements.filter(e => e.type === 'shape').length
        };
            
            Object.keys(counts).forEach(type => {
                const quotaEl = document.getElementById(`quota-${type}`);
                if (quotaEl) {
                    quotaEl.textContent = `${counts[type]}/${LIMITS[type]}`;
                }
            });
            
            // Update button states
            Object.keys(LIMITS).forEach(type => {
                const button = document.querySelector(`[onclick="addElement('${type}')"]`);
                if (button) {
                    const count = counts[type] || 0;
                    const limit = LIMITS[type];
                    button.disabled = count >= limit;
                }
            });
        }

        // Update layers panel
        function updateLayersPanel() {
            const layersList = document.getElementById('layers-list');
            
            if (elements.length === 0) {
                layersList.innerHTML = '<div class="no-layers">No elements added yet</div>';
                return;
            }
            
            // Sort elements by layer (highest layer first)
            const sortedElements = [...elements].sort((a, b) => b.layer - a.layer);
            
            layersList.innerHTML = sortedElements.map(element => {
                const icon = getElementIcon(element.type);
                const name = getElementDisplayName(element);
                const details = getElementDetails(element);
                const isSelected = selectedElement === element.id;
                
                return `
                    <div class="layer-item ${isSelected ? 'selected' : ''}" data-id="${element.id}">
                        <div class="layer-icon">${icon}</div>
                        <div class="layer-info">
                            <div class="layer-name">${name}</div>
                            <div class="layer-details">${details}</div>
                        </div>
                        <div class="layer-controls">
                            <button class="layer-btn" onclick="moveLayerUp(${element.id})" title="Move Up">↑</button>
                            <button class="layer-btn" onclick="moveLayerDown(${element.id})" title="Move Down">↓</button>
                            <button class="layer-btn delete" onclick="deleteElementFromLayer(${element.id})" title="Delete">×</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add click listeners to layer items
            layersList.querySelectorAll('.layer-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('layer-btn')) {
                        const id = parseInt(item.dataset.id);
                        selectElement(id);
                    }
                });
            });
        }

        // Get element icon
        function getElementIcon(type) {
            const icons = {
                text: 'T',
                image: '🖼',
                discord_profile: '💬',
                roblox_profile: '🎮',
                progressbar: '📊',
                shape: '⬜'
            };
            return icons[type] || '?';
        }

        // Get element display name
        function getElementDisplayName(element) {
            if (element.type === 'text') {
                return element.text || 'Text';
            } else if (element.type === 'image') {
                return 'Image';
            } else if (element.type === 'discord_profile') {
                return element.userId ? `Discord (${element.userId})` : 'Discord Profile';
            } else if (element.type === 'roblox_profile') {
                return element.name ? 'Roblox User' : 'Roblox Profile';
            } else if (element.type === 'progressbar') {
                return `Progress (${element.progressValue}/${element.progressMax})`;
            } else if (element.type === 'shape') {
                return 'Shape';
            }
            return element.type;
        }

        // Get element details
        function getElementDetails(element) {
            if (element.type === 'text') {
                return `${element.fontSize}px ${element.fontFamily}`;
            } else if (element.type === 'image') {
                return `${Math.round(element.width)}×${Math.round(element.height)}`;
            } else if (element.type === 'discord_profile') {
                return `Radius: ${element.borderRadius || 100}`;
            } else if (element.type === 'roblox_profile') {
                return element.subtitle || 'Profile';
            } else if (element.type === 'progressbar') {
                return `${Math.round(element.width)}×${Math.round(element.height)}`;
            } else if (element.type === 'shape') {
                return `${Math.round(element.width)}×${Math.round(element.height)}`;
            }
            return `Layer ${element.layer}`;
        }

        // Move layer up
        function moveLayerUp(id) {
            const element = elements.find(e => e.id === id);
            if (element) {
                element.layer = Math.max(...elements.map(e => e.layer), 0) + 1;
                updateCanvas();
                updateJSON();
            }
        }

        // Move layer down
        function moveLayerDown(id) {
            const element = elements.find(e => e.id === id);
            if (element) {
                element.layer = Math.max(1, element.layer - 1);
                updateCanvas();
                updateJSON();
            }
        }

        // Delete element from layer
        function deleteElementFromLayer(id) {
            elements = elements.filter(e => e.id !== id);
            if (selectedElement === id) {
                selectedElement = null;
                updateElementProperties();
            }
            updateCanvas();
            updateQuotas();
            updateJSON();
        }

        // Update JSON output
        function updateJSON() {
            try {
                const cardWidth = parseInt(document.getElementById('card-width').value);
                const cardHeight = parseInt(document.getElementById('card-height').value);
                const bgType = document.getElementById('bg-type').value;
                const bgColor = document.getElementById('bg-color').value;
                const bgImage = document.getElementById('bg-image').value;
                const isTransparent = document.getElementById('bg-transparent').checked;
            
            const payload = {
                card: {
                    width: String(cardWidth),
                    height: String(cardHeight),
                    bg: isTransparent ? '#00000000' : (bgType === 'color' ? bgColor : bgImage),
                    bg_type: bgType
                },
                elements: elements.map(element => {
                    const base = {
                        id: String(element.id),
                        type: element.type,
                        layer: String(element.layer),
                        transparency: String(element.opacity),
                        position: {
                            x: Number(element.x),
                            y: Number(element.y)
                        },
                        size: {
                            width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                            height: Number(element.height)
                        }
                    };
                    
                    if (element.type === 'text') {
                        // Group all text properties together
                        return {
                            id: String(element.id),
                            type: element.type,
                            text: element.text,
                            text_size: String(element.fontSize),
                            font: element.fontFamily,
                            color: element.textColor,
                            transparency: String(element.opacity),
                            layer: String(element.layer),
                            position: {
                                x: Number(element.x),
                                y: Number(element.y)
                            },
                            size: {
                                width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                                height: Number(element.height)
                            }
                        };
                    } else if (element.type === 'image') {
                        base.url = element.imageUrl;
                    } else if (element.type === 'discord_profile') {
                        return {
                            id: String(element.id),
                            type: element.type,
                            user_id: element.userId,
                            transparency: String(element.opacity),
                            layer: String(element.layer),
                            border_radius: String(element.borderRadius || 100),
                            position: {
                                x: Number(element.x),
                                y: Number(element.y)
                            },
                            size: {
                                width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                                height: Number(element.height)
                            }
                        };
                    } else if (element.type === 'roblox_profile') {
                        return {
                            id: String(element.id),
                            type: element.type,
                            user: element.name || 'Username',
                            transparency: String(element.opacity),
                            layer: String(element.layer),
                            border_radius: String(element.borderRadius || 100),
                            position: {
                                x: Number(element.x),
                                y: Number(element.y)
                            },
                            size: {
                                width: element.widthAuto || element.width === 'auto' ? 'auto' : Number(element.width),
                                height: Number(element.height)
                            }
                        };
                    } else if (element.type === 'progressbar') {
                        base.value = Number(element.progressValue);
                        base.max = Number(element.progressMax);
                        base.color = element.progressColor;
                        base.bg_color = element.progressBgColor;
                        base.border_radius = Number(element.progressBorderRadius);
                    } else if (element.type === 'shape') {
                        base.fill = element.shapeFill;
                        base.radius = Number(element.shapeRadius);
                    }
                    
                    return base;
                })
            };
            
                const jsonString = JSON.stringify(payload, null, 2);
                document.getElementById('json-output').value = jsonString;
            } catch (error) {
                // Error updating JSON
            }
        }

        // Fetch Discord avatar
        async function fetchDiscordAvatar(username, element) {
            try {
                // Clean username (remove # and numbers)
                const cleanUsername = username.replace(/#\d{4}$/, '').trim();
                
                if (!cleanUsername) return;
                
                // Show loading state
                element.avatarUrl = '';
                updateCanvas();
                
                // Try to get Discord user ID from username using Discord's public API
                // This is a simplified approach - for production you'd need proper Discord API integration
                
                // For now, we'll use Discord's default avatar system
                // Generate a hash from the username for consistent avatar
                const hash = simpleHash(cleanUsername);
                const avatarIndex = hash % 5; // 5 default Discord avatars
                
                const avatarUrl = `https://cdn.discordapp.com/embed/avatars/${avatarIndex}.png`;
                
                // Update element with fetched avatar
                element.avatarUrl = avatarUrl;
                document.getElementById('prop-avatar-url').value = avatarUrl;
                
                updateCanvas();
                updateJSON();
                
            } catch (error) {
                // Keep current avatar or use default
            }
        }

        // Simple hash function for consistent avatar selection
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            return Math.abs(hash);
        }

        // Copy JSON
        function copyJSON() {
            const jsonOutput = document.getElementById('json-output');
            jsonOutput.select();
            document.execCommand('copy');
            
            // Show feedback
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.style.background = 'linear-gradient(135deg, #2ed573 0%, #1e90ff 100%)';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = 'linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%)';
            }, 2000);
        }
    </script>
</body>
</html>
